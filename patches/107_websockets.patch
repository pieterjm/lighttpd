--- a/src/base64.c	1969-12-31 16:00:00.000000000 -0800
+++ b/src/base64.c	2012-11-14 16:22:34.706025984 -0800
@@ -0,0 +1,139 @@
+/*
+ * $Id$
+ *
+ * Copyright(c) 2010, Norio Kobota, All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ *   this list of conditions and the following disclaimer.
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ * - Neither the name of the 'incremental' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "base64.h"
+
+static const char base64_encode_chars[] =
+	"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+	"abcdefghijklmnopqrstuvwxyz"
+	"0123456789+/";
+
+static const signed char base64_decode_chars[] = {
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1,  62, - 1, - 1, - 1,  63,
+	 52,  53,  54,  55,  56,  57,  58,  59,
+	 60,  61, - 1, - 1, - 1,   0, - 1, - 1,
+	- 1,   0,   1,   2,   3,   4,   5,   6,
+	  7,   8,   9,  10,  11,  12,  13,  14,
+	 15,  16,  17,  18,  19,  20,  21,  22,
+	 23,  24,  25, - 1, - 1, - 1, - 1, - 1,
+	- 1,  26,  27,  28,  29,  30,  31,  32,
+	 33,  34,  35,  36,  37,  38,  39,  40,
+	 41,  42,  43,  44,  45,  46,  47,  48,
+	 49,  50,  51, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1,
+	- 1, - 1, - 1, - 1, - 1, - 1, - 1, - 1};
+
+int
+base64_encode(unsigned char **dst, size_t *dstsiz, const unsigned char *src, size_t srcsiz) {
+    unsigned long x = 0UL;
+    int i = 0, l = 0;
+    unsigned char *pdst;
+
+    *dst = (unsigned char *)malloc(srcsiz * 2);
+    if (!*dst) {
+        return -1;
+    }
+    pdst = *dst;
+    *dstsiz = 0;
+    for (; srcsiz > 0; src++, srcsiz--) {
+        x = x << 8 | *src;
+        for (l += 8; l >= 6; l -= 6) {
+            pdst[i++] = base64_encode_chars[(x >> (l - 6)) & 0x3f];
+        }
+    }
+    if (l > 0) {
+        x <<= 6 - l;
+        pdst[i++] = base64_encode_chars[x & 0x3f];
+    }
+    for (; i % 4;) {
+        pdst[i++] = '=';
+    }
+    *dstsiz = i;
+    pdst[i] = '\0';
+    return 0;
+}
+
+int
+base64_decode(unsigned char **dst, size_t *dstsiz, const unsigned char *src) {
+    union {
+        unsigned long x;
+        char c[4];
+    } base64;
+    unsigned char *pdst;
+    int i, j = 0;
+    size_t srcsiz = strlen((const char *)src);
+
+    if ((srcsiz % 4) != 0) {
+        return -1;
+    }
+    base64.x = 0UL;
+    *dst = (unsigned char *)malloc(srcsiz);
+    if (!*dst) {
+        return -1;
+    }
+    pdst = *dst;
+    *dstsiz = 0;
+    for (; srcsiz > 0; src+=4, srcsiz-=4) {
+        for (i = 0; i < 4; i++) {
+            if (base64_decode_chars[src[i]] == -1) {
+                return -1;
+            }
+            base64.x = base64.x << 6 | base64_decode_chars[src[i]];
+            j += (src[i] == '=');
+        }
+        for (i = 3; i > j; i--, (*dstsiz)++) {
+            *pdst++ = base64.c[i - 1];
+        }
+    }
+    *pdst = '\0';
+    return 0;
+}
--- a/src/base64.h	1969-12-31 16:00:00.000000000 -0800
+++ b/src/base64.h	2012-11-14 16:22:34.706025984 -0800
@@ -0,0 +1,47 @@
+/*
+ * $Id$
+ *
+ * Copyright(c) 2010, Norio Kobota, All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ *   this list of conditions and the following disclaimer.
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ * - Neither the name of the 'incremental' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	_MOD_WEBSOCKET_BASE64_H_
+#define	_MOD_WEBSOCKET_BASE64_H_
+
+#include "stdio.h"
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+    int base64_encode(unsigned char **, size_t *, const unsigned char *, size_t);
+    int base64_decode(unsigned char **, size_t *, const unsigned char *);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _MOD_WEBSOCKET_BASE64_H_ */
--- a/src/mod_websocket.c	1969-12-31 16:00:00.000000000 -0800
+++ b/src/mod_websocket.c	2012-11-14 16:22:34.706025984 -0800
@@ -0,0 +1,925 @@
+/*
+ * $Id$
+ *
+ * Copyright(c) 2010, Norio Kobota, All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ *   this list of conditions and the following disclaimer.
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ * - Neither the name of the 'incremental' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <string.h>
+#include <errno.h>
+
+#include "connections.h"
+#include "fdevent.h"
+#include "joblist.h"
+#include "log.h"
+
+#include "mod_websocket.h"
+
+#ifdef	HAVE_SYS_FILIO_H
+# include <sys/filio.h>
+#endif	/* HAVE_SYS_FILIO_H */
+
+/* prototypes */
+static handler_ctx *_handler_ctx_init(void);
+static void _handler_ctx_free(handler_ctx *);
+static int _set_subproto_extension(data_array *, const data_array *);
+static int _set_extension(data_array *, const data_array *);
+static int _tcp_server_connect(handler_ctx *);
+static void _tcp_server_disconnect(handler_ctx *);
+static handler_t _handle_fdevent(server *, void *, int);
+static int _dispatch_request(server *, connection *, plugin_data *);
+static handler_t _check_request(server *, connection *, void *);
+static handler_t _disconnect(server *, connection *, void *);
+static handler_t _handle_subrequest(server *, connection *, void *);
+
+handler_ctx *_handler_ctx_init(void) {
+    handler_ctx *hctx = calloc(1, sizeof(*hctx));
+
+    if (!hctx) {
+        return NULL;
+    }
+    hctx->state = MOD_WEBSOCKET_STATE_INIT;
+
+    hctx->handshake.host = NULL;
+    hctx->handshake.origin = NULL;
+    hctx->handshake.subproto = NULL;
+
+#ifdef	_MOD_WEBSOCKET_SPEC_IETF_00_
+    hctx->handshake.key1 = NULL;
+    hctx->handshake.key2 = NULL;
+    hctx->handshake.key3 = buffer_init();
+#endif	/* _MOD_WEBSOCKET_SPEC_IETF_00_ */
+
+#ifdef	_MOD_WEBSOCKET_RFC_6455_
+    hctx->handshake.key = NULL;
+#endif	/* _MOD_WEBSOCKET_RFC_6455_ */
+
+    hctx->frame.state = MOD_WEBSOCKET_FRAME_STATE_INIT;
+    hctx->frame.ctl.siz = 0;
+    hctx->frame.type = MOD_WEBSOCKET_FRAME_TYPE_CLOSE;
+    hctx->frame.type_before = MOD_WEBSOCKET_FRAME_TYPE_CLOSE;
+    hctx->frame.payload = buffer_init();
+    hctx->tosrv = chunkqueue_init();
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+    hctx->cnv = NULL;
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+    hctx->fd = -1;
+    hctx->fd_idx = -1;
+
+    hctx->srv = NULL;
+    hctx->con = NULL;
+    hctx->ext = NULL;
+    hctx->pd = NULL;
+
+    hctx->fromcli = NULL;
+    hctx->tocli = NULL;
+
+    return hctx;
+}
+
+void _handler_ctx_free(handler_ctx *hctx) {
+    if (!hctx) {
+        return;
+    }
+
+#ifdef	_MOD_WEBSOCKET_SPEC_IETF_00_
+    buffer_free(hctx->handshake.key3);
+#endif	/* _MOD_WEBSOCKET_SPEC_IETF_00_ */
+
+    buffer_free(hctx->frame.payload);
+    chunkqueue_free(hctx->tosrv);
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+    mod_websocket_conv_final(hctx->cnv);
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+    _tcp_server_disconnect(hctx);
+    free(hctx);
+    return;
+}
+
+int _set_subproto_extension(data_array *dst, const data_array *src) {
+    size_t i, j;
+    data_unset *data = NULL;
+    data_string *host = NULL;
+    data_string *port = NULL;
+    data_array *da_origins = NULL;
+    data_array *origins = NULL;
+    data_string *origin = NULL;
+    data_string *type = NULL;
+    buffer *key = NULL;
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+    data_string *locale = NULL;
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+    for (i = src->value->used; i > 0; i--) {
+        data = src->value->data[i - 1];
+        key = data->key;
+        if ( 0 == strcmp(key->ptr, MOD_WEBSOCKET_CONFIG_HOST) ) {
+            host = data_string_init();
+            buffer_copy_string_buffer(host->key, key);
+            buffer_copy_string_buffer(host->value,
+                                      ((data_string *)data)->value);
+            array_insert_unique(dst->value, (data_unset *)host);
+        } else if ( 0 == strcmp(key->ptr, MOD_WEBSOCKET_CONFIG_PORT) ) {
+            port = data_string_init();
+            buffer_copy_string_buffer(port->key, key);
+            buffer_copy_string_buffer(port->value,
+                                      ((data_string *)data)->value);
+            array_insert_unique(dst->value, (data_unset *)port);
+        } else if ( 0 == strcmp(key->ptr, MOD_WEBSOCKET_CONFIG_SUBPROTO) ) {
+            buffer_copy_string_buffer(dst->key, ((data_string *)data)->value);
+        } else if ( 0 == strcmp(key->ptr, MOD_WEBSOCKET_CONFIG_ORIGINS) ) {
+            origins = data_array_init();
+            buffer_copy_string_len(origins->key,
+                                   CONST_STR_LEN(MOD_WEBSOCKET_CONFIG_ORIGINS));
+            if (data->type == TYPE_STRING) {
+                origin = data_string_init();
+                buffer_copy_string_buffer(origin->value,
+                                          ((data_string *)data)->value);
+                array_insert_unique(origins->value, (data_unset *)origin);
+            } else if (data->type == TYPE_ARRAY) {
+                da_origins = (data_array *)data;
+                for (j = da_origins->value->used; j > 0; j--) {
+                    origin = data_string_init();
+                    buffer_copy_string_buffer(origin->value,
+                                              ((data_string *)da_origins->value->data[j - 1])->value);
+                    array_insert_unique(origins->value, (data_unset *)origin);
+                }
+            }
+            array_insert_unique(dst->value, (data_unset *)origins);
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+        } else if ( 0 == strcmp(key->ptr, MOD_WEBSOCKET_CONFIG_LOCALE) ) {
+            locale = data_string_init();
+            buffer_copy_string_buffer(locale->key, key);
+            buffer_copy_string_buffer(locale->value,
+                                      ((data_string *)data)->value);
+            array_insert_unique(dst->value, (data_unset *)locale);
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+        } else if ( 0 == strcmp(key->ptr, MOD_WEBSOCKET_CONFIG_TYPE) ) {
+            type = data_string_init();
+            buffer_copy_string_buffer(type->key, key);
+            buffer_copy_string_buffer(type->value,
+                                      ((data_string *)data)->value);
+            array_insert_unique(dst->value, (data_unset *)type);
+        }
+    }
+    if (!host || !port) {
+        return -1;
+    }
+    return 0;
+}
+
+int _set_extension(data_array *dst, const data_array *src) {
+    int ret = -1;
+    size_t i;
+    data_array *subproto;
+
+    if (!dst || !src) {
+        return ret;
+    }
+    buffer_copy_string_buffer(dst->key, src->key);
+    if (src->value->data[0]->type == TYPE_STRING) {
+        subproto = data_array_init();
+        buffer_reset(subproto->key);
+        ret = _set_subproto_extension(subproto, src);
+        array_insert_unique(dst->value, (data_unset *)subproto);
+    } else if (src->value->data[0]->type == TYPE_ARRAY) {
+        for (i = src->value->used; i > 0; i--) {
+            data_array *da_src = (data_array *)src->value->data[i - 1];
+
+            subproto = data_array_init();
+            buffer_reset(subproto->key);
+            ret = _set_subproto_extension(subproto, da_src);
+            if (subproto->key->ptr &&
+                array_get_element(dst->value, subproto->key->ptr)) {
+                ret = -1;
+            }
+            if (!subproto->key->ptr && dst->value->used) {
+                ret = -1;
+            }
+            array_insert_unique(dst->value, (data_unset *)subproto);
+            if (0 != ret) {
+                break;
+            }
+        }
+    }
+    return ret;
+}
+
+int _tcp_server_connect(handler_ctx *hctx) {
+    data_unset *du;
+    buffer *host = NULL;
+    buffer *port = NULL;
+    int flag = 1;
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+    char *locale = NULL;
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+    du = array_get_element(hctx->ext->value, MOD_WEBSOCKET_CONFIG_HOST);
+    if (!du) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "BUG: invalid config");
+        hctx->con->http_status = MOD_WEBSOCKET_INTERNAL_SERVER_ERROR;
+        hctx->con->mode = DIRECT;
+        return -1;
+    }
+    host = ((data_string *)du)->value;
+    if (!host) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "BUG: invalid config");
+        hctx->con->http_status = MOD_WEBSOCKET_INTERNAL_SERVER_ERROR;
+        hctx->con->mode = DIRECT;
+        return -1;
+    }
+    du = array_get_element(hctx->ext->value, MOD_WEBSOCKET_CONFIG_PORT);
+    if (!du) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "BUG: invalid config");
+        hctx->con->http_status = MOD_WEBSOCKET_INTERNAL_SERVER_ERROR;
+        hctx->con->mode = DIRECT;
+        return -1;
+    }
+    port = ((data_string *)du)->value;
+    if (!port) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "BUG: invalid config");
+        hctx->con->http_status = MOD_WEBSOCKET_INTERNAL_SERVER_ERROR;
+        hctx->con->mode = DIRECT;
+        return -1;
+    }
+    hctx->fd = mod_websocket_tcp_server_connect(host->ptr, port->ptr);
+    if (hctx->fd < 0) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_WARNING,
+                  "s", "fail to connect backend server");
+        hctx->con->http_status = MOD_WEBSOCKET_SERVICE_UNAVAILABLE;
+        hctx->con->mode = DIRECT;
+        return -1;
+    }
+    if (setsockopt(hctx->fd, IPPROTO_TCP, TCP_NODELAY,
+                   &flag, sizeof(flag)) == -1) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "fail to set TCP_NODELAY");
+        _tcp_server_disconnect(hctx);
+        hctx->con->http_status = MOD_WEBSOCKET_INTERNAL_SERVER_ERROR;
+        hctx->con->mode = DIRECT;
+        return HANDLER_FINISHED;
+    }
+    if (setsockopt(hctx->con->fd, IPPROTO_TCP, TCP_NODELAY,
+                   &flag, sizeof(flag)) == -1) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "fail to set TCP_NODELAY");
+        _tcp_server_disconnect(hctx);
+        hctx->con->http_status = MOD_WEBSOCKET_INTERNAL_SERVER_ERROR;
+        hctx->con->mode = DIRECT;
+        return HANDLER_FINISHED;
+    }
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+    du = array_get_element(hctx->ext->value, MOD_WEBSOCKET_CONFIG_LOCALE);
+    if (!du) {
+        locale = MOD_WEBSOCKET_UTF8_STR;
+    } else {
+        locale = (((data_string *)du)->value) ?
+            ((data_string *)du)->value->ptr : MOD_WEBSOCKET_UTF8_STR;
+    }
+    hctx->cnv = mod_websocket_conv_init(locale);
+    if (!hctx->cnv) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+        _tcp_server_disconnect(hctx);
+        hctx->con->http_status = MOD_WEBSOCKET_INTERNAL_SERVER_ERROR;
+        hctx->con->mode = DIRECT;
+        return HANDLER_FINISHED;
+    }
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+    hctx->fd_idx = -1;
+    hctx->srv->cur_fds++;
+    fdevent_register(hctx->srv->ev, hctx->fd, _handle_fdevent, hctx);
+    fdevent_event_set(hctx->srv->ev, &(hctx->fd_idx), hctx->fd, FDEVENT_IN);
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+    DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+              "sdsdssssss", "connected client fd:", hctx->con->fd,
+              " -> server fd:", hctx->fd,
+              "(", host->ptr, ":", port->ptr, "), locale:", locale);
+#else
+    DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+              "sdsdsssss", "connected client fd:", hctx->con->fd,
+              " -> server fd:", hctx->fd,
+              "(", host->ptr, ":", port->ptr, "), locale: unused");
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+    return 0;
+}
+
+void _tcp_server_disconnect(handler_ctx *hctx) {
+    if (hctx->fd > 0) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                  "sd", "disconnect server:", hctx->fd);
+        fdevent_event_del(hctx->srv->ev, &(hctx->fd_idx), hctx->fd);
+        fdevent_unregister(hctx->srv->ev, hctx->fd);
+        mod_websocket_tcp_server_disconnect(hctx->fd);
+        hctx->srv->cur_fds--;
+        hctx->fd = -1;
+    }
+}
+
+handler_t _handle_fdevent(server *srv, void *ctx, int revents) {
+    handler_ctx *hctx = (handler_ctx *)ctx;
+    mod_websocket_frame_type_t frame_type;
+    char readbuf[UINT16_MAX];
+    ssize_t siz;
+    data_string *type;
+
+    if (revents & FDEVENT_NVAL) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                  "sdsd",
+                  "recv NVAL event: fd(srv) =", hctx->fd,
+                  "fd(cli) =", hctx->con->fd);
+        _tcp_server_disconnect(hctx);
+    } else if (revents & FDEVENT_HUP || revents & FDEVENT_ERR) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                  "sdsd",
+                  "recv HUP or ERR event: fd(srv) =", hctx->fd,
+                  "fd(cli) =", hctx->con->fd);
+        _tcp_server_disconnect(hctx);
+    } else if (revents & FDEVENT_IN) {
+        errno = 0;
+        memset(readbuf, 0, sizeof(readbuf));
+        siz = read(hctx->fd, readbuf, UINT16_MAX - 1);
+        if (siz == 0) {
+            _tcp_server_disconnect(hctx);
+        } else if (siz > 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                      "sdsx",
+                      "recv from server fd:", hctx->fd,
+                      ", size:", siz);
+            if (hctx->state == MOD_WEBSOCKET_STATE_CONNECTED) {
+                type = (data_string *)
+                    array_get_element(hctx->ext->value,
+                                      MOD_WEBSOCKET_CONFIG_TYPE);
+
+                if (type &&
+                    0 == strcasecmp(type->value->ptr, MOD_WEBSOCKET_BIN_STR)) {
+                    frame_type = MOD_WEBSOCKET_FRAME_TYPE_BIN;
+                } else {
+                    frame_type = MOD_WEBSOCKET_FRAME_TYPE_TEXT;
+                }
+                if (mod_websocket_frame_send(hctx, frame_type,
+                                             readbuf, (size_t)siz) < 0) {
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                              "sd", "failed to send frame:", hctx->fd);
+                    _tcp_server_disconnect(hctx);
+                }
+            }
+        } else if (errno != EAGAIN && errno != EINTR) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                      "ss", "can't read from server:", strerror(errno));
+            _tcp_server_disconnect(hctx);
+        } else {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                      "s", strerror(errno));
+        }
+    }
+    return _handle_subrequest(srv, hctx->con, hctx->pd);
+}
+
+int _dispatch_request(server *srv, connection *con, plugin_data *p) {
+    size_t i, j;
+    plugin_config *s = p->config_storage[0];
+
+#define PATCH(x) do { p->conf.x = s->x; } while (0)
+
+    PATCH(exts);
+    PATCH(debug);
+    PATCH(timeout);
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+    PATCH(ping);
+#endif	/* _MOD_WEBSOCKET_RFC_6455_ */
+
+    /* skip the first, the global context */
+    for (i = 1; i < srv->config_context->used; i++) {
+        data_config *dc = (data_config *)srv->config_context->data[i];
+        s = p->config_storage[i];
+
+        /* condition didn't match */
+        if (!config_check_cond(srv, con, dc)) {
+            continue;
+        }
+        /* merge config */
+        for (j = 0; j < dc->value->used; j++) {
+            data_unset *du = dc->value->data[j];
+
+            if (buffer_is_equal_string(du->key, CONST_STR_LEN(MOD_WEBSOCKET_CONFIG_SERVER))) {
+                PATCH(exts);
+            } else if (buffer_is_equal_string(du->key, CONST_STR_LEN(MOD_WEBSOCKET_CONFIG_DEBUG))) {
+                PATCH(debug);
+            }
+        }
+    }
+#undef PATCH
+    if (!p->conf.exts) {
+        return -1;
+    }
+    return 0;
+}
+
+handler_t _check_request(server *srv, connection *con, void *p_d) {
+    plugin_data *p = p_d;
+    size_t i;
+    data_array *ext = NULL;
+    handler_ctx *hctx = NULL;
+
+    if (con->request.http_method != HTTP_METHOD_GET) {
+        return HANDLER_GO_ON;
+    }
+    if (_dispatch_request(srv, con, p) < 0) {
+        return HANDLER_GO_ON;
+    }
+    for (i = p->conf.exts->used; i > 0; i--) {
+        ext = (data_array *)p->conf.exts->data[i - 1];
+        if (0 == strcmp(con->uri.path->ptr, ext->key->ptr)) {
+            break;
+        }
+        ext = NULL;
+    }
+    if (!ext) {
+        return HANDLER_GO_ON;
+    }
+    if (p->conf.debug > MOD_WEBSOCKET_LOG_INFO) {
+        log_error_write(srv, __FILE__, __LINE__, "ss",
+                        "found extension:", ext->key->ptr);
+    }
+    /* init handler-context */
+    hctx = _handler_ctx_init();
+    if (!hctx) {
+        if (p->conf.debug) {
+            log_error_write(srv, __FILE__, __LINE__, "s", "no memory.");
+        }
+        return HANDLER_ERROR;
+    }
+    con->plugin_ctx[p->id] = hctx;
+    con->mode = p->id;
+    hctx->srv = srv;
+    hctx->con = con;
+    hctx->ext = ext;
+    hctx->pd = p;
+    hctx->fromcli = con->read_queue;
+    hctx->tocli = con->write_queue;
+    return HANDLER_GO_ON;
+}
+
+handler_t _disconnect(server *srv, connection *con, void *pd) {
+    plugin_data *p = (plugin_data *)pd;
+    handler_ctx *hctx = con->plugin_ctx[p->id];
+
+    srv = srv; // suppress warning
+    if (con->plugin_ctx[p->id]) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                  "sd", "disconnect client:", hctx->con->fd);
+        if (hctx->fd > 0) {
+            _tcp_server_disconnect(hctx);
+        }
+        _handler_ctx_free(hctx);
+        con->plugin_ctx[p->id] = NULL;
+    }
+    return HANDLER_GO_ON;
+}
+
+INIT_FUNC(_init) {
+    plugin_data *p = NULL;
+
+    p = calloc(1, sizeof(*p));
+    return p;
+}
+
+FREE_FUNC(_free) {
+    size_t i;
+    plugin_data *p = p_d;
+    plugin_config *s = NULL;
+
+    if (p->config_storage) {
+        for (i = 0; i < srv->config_context->used; i++) {
+            s = p->config_storage[i];
+            if (s) {
+                array_free(s->exts);
+                free(s);
+            }
+        }
+        free(p->config_storage);
+    }
+    free(p);
+    return HANDLER_GO_ON;
+}
+
+SETDEFAULTS_FUNC(_set_defaults) {
+    plugin_data *p = p_d;
+    size_t i, j;
+    array *cfg_ctx = srv->config_context;
+
+    p->config_storage = calloc(1, cfg_ctx->used * sizeof(specific_config *));
+    if (!p->config_storage) {
+        log_error_write(srv, __FILE__, __LINE__, "s", "no memory.");
+        return HANDLER_ERROR;
+    }
+    for (i = 0; i < cfg_ctx->used; i++) {
+        plugin_config *s = NULL;
+        array *ca = NULL;
+        data_unset *du = NULL;
+        data_array *da = NULL;
+        data_array *ext = NULL;
+        config_values_t cv[] = {
+            { MOD_WEBSOCKET_CONFIG_SERVER, NULL,
+              T_CONFIG_LOCAL, T_CONFIG_SCOPE_CONNECTION },
+            { MOD_WEBSOCKET_CONFIG_TIMEOUT,  NULL,
+              T_CONFIG_SHORT, T_CONFIG_SCOPE_CONNECTION },
+            { MOD_WEBSOCKET_CONFIG_DEBUG,  NULL,
+              T_CONFIG_SHORT, T_CONFIG_SCOPE_CONNECTION },
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+            { MOD_WEBSOCKET_CONFIG_PING_INTERVAL,  NULL,
+              T_CONFIG_SHORT, T_CONFIG_SCOPE_CONNECTION },
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+            { NULL,                        NULL,
+              T_CONFIG_UNSET, T_CONFIG_SCOPE_UNSET }
+        };
+
+        s = malloc(sizeof(plugin_config));
+        if (!s) { /* p->config_storage is freed in FREE_FUNC */
+            log_error_write(srv, __FILE__, __LINE__, "s", "no memory");
+            return HANDLER_ERROR;
+        }
+        s->exts = array_init();
+        s->timeout = MOD_WEBSOCKET_DEFAULT_TIMEOUT_SEC;
+        s->debug = 0;
+
+        cv[0].destination = s->exts;
+        cv[1].destination = &(s->timeout);
+        cv[2].destination = &(s->debug);
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+        s->ping = 0;
+        cv[3].destination = &(s->ping);
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+        p->config_storage[i] = s;
+
+        ca = ((data_config *)(cfg_ctx->data[i]))->value;
+        if (config_insert_values_global(srv, ca, cv)) {
+            return HANDLER_ERROR;
+        }
+        du = array_get_element(ca, MOD_WEBSOCKET_CONFIG_SERVER);
+        if (!du) {
+            continue;
+        }
+        if (du->type != TYPE_ARRAY) {
+            log_error_write(srv, __FILE__, __LINE__, "ss",
+                            MOD_WEBSOCKET_CONFIG_SERVER,
+                            "must be array");
+            return HANDLER_ERROR;
+        }
+
+        da = (data_array *)du;
+        for (j = 0; j < da->value->used; j++) {
+            int ret;
+            data_array *da_src = (data_array *)da->value->data[j];
+
+            if (da_src->type != TYPE_ARRAY) {
+                log_error_write(srv, __FILE__, __LINE__, "ss",
+                                da_src->key->ptr,
+                                "must be array");
+                return HANDLER_ERROR;
+            }
+            ext = data_array_init();
+            ret = _set_extension(ext, da_src);
+            array_insert_unique(s->exts, (data_unset *)ext);
+            if (0 != ret) {
+                log_error_write(srv, __FILE__, __LINE__, "ss",
+                                "configuration error:",
+                                da_src->key->ptr);
+                return HANDLER_ERROR;
+            }
+        }
+    }
+    return HANDLER_GO_ON;
+}
+
+SUBREQUEST_FUNC(_handle_subrequest) {
+    plugin_data *p = p_d;
+    handler_ctx *hctx = con->plugin_ctx[p->id];
+    int ret;
+    mod_websocket_errno_t wsret;
+    data_string *type = NULL;
+
+    if (!hctx) {
+        return HANDLER_GO_ON;
+    }
+    /* not my job */
+    if (con->mode != p->id) {
+        return HANDLER_GO_ON;
+    }
+
+    switch (hctx->state) {
+    case MOD_WEBSOCKET_STATE_INIT:
+        /* check request */
+        wsret = mod_websocket_handshake_check_request(hctx);
+        if (wsret == MOD_WEBSOCKET_NOT_WEBSOCKET) {
+            return HANDLER_GO_ON;
+        } else if (wsret != MOD_WEBSOCKET_OK) {
+            hctx->con->http_status = wsret;
+            hctx->con->mode = DIRECT;
+            return HANDLER_FINISHED;
+        }
+        /* auto base64 {encode, decode} for hybi-00 */
+        if (hctx->handshake.version == 0) {
+            type = (data_string *)
+                array_get_element(hctx->ext->value,
+                                  MOD_WEBSOCKET_CONFIG_TYPE);
+            if (type &&
+                0 == strcasecmp(type->value->ptr, MOD_WEBSOCKET_BIN_STR)) {
+                DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                          "s", "specified binary type on hybi-00 spec.");
+                hctx->frame.type = MOD_WEBSOCKET_FRAME_TYPE_BIN;
+            } else {
+                hctx->frame.type = MOD_WEBSOCKET_FRAME_TYPE_TEXT;
+            }
+        }
+        /* connect to backend server */
+        if (_tcp_server_connect(hctx) < 0) {
+            return HANDLER_FINISHED;
+        }
+        /* create response */
+        wsret = mod_websocket_handshake_create_response(hctx);
+        if (wsret != MOD_WEBSOCKET_OK) {
+            _tcp_server_disconnect(hctx);
+            hctx->con->http_status = wsret;
+            hctx->con->mode = DIRECT;
+            return HANDLER_FINISHED;
+        }
+        hctx->state = MOD_WEBSOCKET_STATE_SEND_RESPONSE;
+
+        /* fall through */
+
+    case MOD_WEBSOCKET_STATE_SEND_RESPONSE:
+        if (((server_socket *)(hctx->con->srv_socket))->is_ssl) {
+
+#ifdef	USE_OPENSSL
+            ret = srv->NETWORK_SSL_BACKEND_WRITE(srv, con,
+                                                 hctx->con->ssl, hctx->tocli);
+#else	/* SSL is not available */
+            ret = -1;
+#endif	/* USE_OPENSSL */
+
+        } else {
+            ret = srv->NETWORK_BACKEND_WRITE(srv, con,
+                                             hctx->con->fd, hctx->tocli);
+        }
+        if (0 <= ret) {
+            chunkqueue_remove_finished_chunks(hctx->tocli);
+        } else {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                      "ss", "send handshake response error:",
+                      strerror(errno));
+            _tcp_server_disconnect(hctx);
+            chunkqueue_reset(hctx->tocli);
+            hctx->con->http_status = MOD_WEBSOCKET_INTERNAL_SERVER_ERROR;
+            hctx->con->mode = DIRECT;
+            return HANDLER_FINISHED;
+        }
+        if (chunkqueue_is_empty(hctx->tocli)) {
+            chunkqueue_reset(hctx->fromcli);
+            hctx->state = MOD_WEBSOCKET_STATE_CONNECTED;
+        }
+        connection_set_state(srv, hctx->con, CON_STATE_READ_CONTINUOUS);
+        hctx->last_access = srv->cur_ts;
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+        hctx->ping_ts = srv->cur_ts;
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+        return HANDLER_WAIT_FOR_EVENT;
+        break;
+
+    case MOD_WEBSOCKET_STATE_CONNECTED:
+        if (hctx->con->fd < 0) {
+            break;
+        } else {
+            if (mod_websocket_frame_recv(hctx) < 0) {
+                break;
+            }
+            if (!chunkqueue_is_empty(hctx->tosrv)) {
+                DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                          "sdsx", "send to server fd:", hctx->fd,
+                          ", size:", chunkqueue_length(hctx->tosrv));
+                ret = srv->NETWORK_BACKEND_WRITE(srv, con,
+                                                 hctx->fd, hctx->tosrv);
+                if (0 <= ret) {
+                    chunkqueue_remove_finished_chunks(hctx->tosrv);
+                } else {
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                              "ss", "can't send data to server:",
+                              strerror(errno));
+                    break;
+                }
+            }
+            hctx->last_access = srv->cur_ts;
+        }
+        if (hctx->fd < 0) {
+            mod_websocket_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE,
+                                     NULL, 0);
+            if (((server_socket *)(hctx->con->srv_socket))->is_ssl) {
+
+#ifdef	USE_OPENSSL
+                srv->NETWORK_SSL_BACKEND_WRITE(srv, con,
+                                               hctx->con->ssl, hctx->tocli);
+#endif	/* USE_OPENSSL */
+
+            } else {
+                srv->NETWORK_BACKEND_WRITE(srv, con,
+                                           hctx->con->fd, hctx->tocli);
+            }
+            chunkqueue_reset(hctx->tocli);
+            break;
+        } else {
+            if (!chunkqueue_is_empty(hctx->tocli)) {
+                if (((server_socket *)(hctx->con->srv_socket))->is_ssl) {
+
+#ifdef	USE_OPENSSL
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                              "sdsx",
+                              "[SSL]send to client fd:", hctx->con->ssl,
+                              ", size:", chunkqueue_length(hctx->tocli));
+                    ret = srv->NETWORK_SSL_BACKEND_WRITE(srv, con,
+                                                         hctx->con->ssl,
+                                                         hctx->tocli);
+#else	/* SSL is not available */
+                    ret = -1;
+#endif	/* USE_OPENSSL */
+
+                } else {
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                              "sdsx", "send to client fd:", hctx->con->fd,
+                              ", size:", chunkqueue_length(hctx->tocli));
+                    ret = srv->NETWORK_BACKEND_WRITE(srv, con,
+                                                     hctx->con->fd,
+                                                     hctx->tocli);
+                }
+                if (0 <= ret) {
+                    chunkqueue_remove_finished_chunks(hctx->tocli);
+                } else {
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                              "ss", "can't send data to client:",
+                              strerror(errno));
+                    _tcp_server_disconnect(hctx);
+                    break;
+                }
+            }
+        }
+        fdevent_event_del(srv->ev, &(hctx->fd_idx), hctx->fd);
+        fdevent_event_del(srv->ev, &(con->fde_ndx), con->fd);
+        if (!chunkqueue_is_empty(hctx->tosrv)) {
+            fdevent_event_set(srv->ev, &(hctx->fd_idx), hctx->fd, FDEVENT_OUT);
+        } else {
+            fdevent_event_set(srv->ev, &(hctx->fd_idx), hctx->fd, FDEVENT_IN);
+        }
+        if (!chunkqueue_is_empty(hctx->tocli)) {
+            fdevent_event_set(srv->ev, &(con->fde_ndx), con->fd, FDEVENT_OUT);
+        } else {
+            fdevent_event_set(srv->ev, &(con->fde_ndx), con->fd, FDEVENT_IN);
+        }
+        connection_set_state(srv, hctx->con, CON_STATE_READ_CONTINUOUS);
+        return HANDLER_WAIT_FOR_EVENT;
+        break;
+    }
+    chunkqueue_reset(hctx->tosrv);
+    chunkqueue_reset(hctx->fromcli);
+    chunkqueue_reset(hctx->tocli);
+    DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+              "sd", "disconnect client:", hctx->con->fd);
+    connection_set_state(srv, con, CON_STATE_CLOSE);
+    _handler_ctx_free(hctx);
+    con->plugin_ctx[p->id] = NULL;
+    return HANDLER_FINISHED;
+}
+
+TRIGGER_FUNC(_handle_trigger) {
+    connection *con;
+    handler_ctx *hctx;
+    plugin_data *p = p_d;
+    size_t i;
+
+    for (i = 0; i < srv->conns->used; i++) {
+        con = srv->conns->ptr[i];
+        if (con->mode != p->id) {
+            continue;
+        }
+        hctx = con->plugin_ctx[p->id];
+        if (!hctx) {
+            continue;
+        }
+        if (p->conf.ping == 0 || hctx->handshake.version == 0) {
+            continue;
+        }
+        if (srv->cur_ts - hctx->ping_ts >= (time_t)p->conf.ping) {
+            mod_websocket_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_PING,
+                                     MOD_WEBSOCKET_PING_STR,
+                                     strlen(MOD_WEBSOCKET_PING_STR));
+            if (((server_socket *)(hctx->con->srv_socket))->is_ssl) {
+
+#ifdef	USE_OPENSSL
+                DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                          "sdsx",
+                          "[SSL]send to client fd:", hctx->con->ssl,
+                          ", size:", chunkqueue_length(hctx->tocli));
+                srv->NETWORK_SSL_BACKEND_WRITE(srv, con,
+                                               hctx->con->ssl,
+                                               hctx->tocli);
+                hctx->ping_ts = srv->cur_ts;
+                chunkqueue_remove_finished_chunks(hctx->tocli);
+#else	/* SSL is not available */
+                chunkqueue_reset(hctx->tocli);
+#endif	/* USE_OPENSSL */
+
+            } else {
+                DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                          "sdsx", "send to client fd:", hctx->con->fd,
+                          ", size:", chunkqueue_length(hctx->tocli));
+                srv->NETWORK_BACKEND_WRITE(srv, con, hctx->con->fd,
+                                           hctx->tocli);
+                hctx->ping_ts = srv->cur_ts;
+                chunkqueue_remove_finished_chunks(hctx->tocli);
+            }
+        }
+
+        if (p->conf.timeout != 0 &&
+            srv->cur_ts - hctx->last_access >= (time_t)p->conf.timeout) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                      "sd", "timeout client:", con->fd);
+            mod_websocket_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE,
+                                     NULL, 0);
+            if (((server_socket *)(hctx->con->srv_socket))->is_ssl) {
+
+#ifdef	USE_OPENSSL
+                srv->NETWORK_SSL_BACKEND_WRITE(srv, con,
+                                               hctx->con->ssl,
+                                               hctx->tocli);
+#endif	/* USE_OPENSSL */
+
+            } else {
+                srv->NETWORK_BACKEND_WRITE(srv, con, hctx->con->fd,
+                                           hctx->tocli);
+            }
+            _tcp_server_disconnect(hctx);
+            chunkqueue_remove_finished_chunks(hctx->tocli);
+            chunkqueue_reset(hctx->tosrv);
+            connection_set_state(srv, con, CON_STATE_CLOSE);
+            _handler_ctx_free(hctx);
+            con->plugin_ctx[p->id] = NULL;
+        }
+    }
+    return HANDLER_GO_ON;
+}
+
+int mod_websocket_plugin_init(plugin *p) {
+    p->version = LIGHTTPD_VERSION_ID;
+    p->name = buffer_init_string("mod_websocket");
+    p->init = _init;
+    p->cleanup = _free;
+    p->set_defaults = _set_defaults;
+    p->connection_reset = _disconnect;
+    p->handle_connection_close = _disconnect;
+    p->handle_uri_clean = _check_request;
+    p->handle_subrequest = _handle_subrequest;
+    p->read_continuous = _handle_subrequest;
+    p->handle_trigger = _handle_trigger;
+    p->data = NULL;
+    return 0;
+}
+
+/* EOF */
--- a/src/mod_websocket_connector.c	1969-12-31 16:00:00.000000000 -0800
+++ b/src/mod_websocket_connector.c	2012-11-14 16:22:34.706025984 -0800
@@ -0,0 +1,106 @@
+/**
+ * $Id$
+ * a part of mod_websocket
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <errno.h>
+
+int
+mod_websocket_tcp_server_connect(const char *host, const char *service) {
+    struct addrinfo hints;
+    struct addrinfo *res = NULL;
+    struct addrinfo *ai = NULL;
+    struct fdlist {
+        int fd;
+        struct fdlist *next;
+    };
+    struct fdlist *head = NULL, *p, *pn, *fde = NULL;
+    int flags, fd, maxfd = -1, connfd = -1, sockret = -1;
+    socklen_t socklen = sizeof(sockret);
+    fd_set fds;
+    struct timeval tv;
+
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_family = AF_UNSPEC;
+    hints.ai_socktype = SOCK_STREAM;
+    hints.ai_flags = 0;
+
+    if (getaddrinfo(host, service, &hints, &res) != 0) {
+        return -1;
+    }
+    FD_ZERO(&fds);
+    for (ai = res; ai; ai = ai->ai_next) {
+        fd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+        if (fd < 0) {
+            goto go_out;
+        }
+        if ((flags = fcntl(fd, F_GETFL, 0)) < 0 ||
+            fcntl(fd, F_SETFL, flags | O_NONBLOCK) < 0) {
+            close(fd);
+            goto go_out;
+        }
+        fde = (struct fdlist *)malloc(sizeof(struct fdlist));
+        if (!fde) {
+            close(fd);
+            goto go_out;
+        }
+        fde->fd = fd;
+        fde->next = head;
+        head = fde;
+        if (fde->fd > maxfd) {
+            maxfd = fde->fd;
+        }
+        FD_SET(fde->fd, &fds);
+        if (connect(fde->fd, ai->ai_addr, ai->ai_addrlen) < 0) {
+            if (errno != EINPROGRESS) {
+                goto go_out;
+            }
+        }
+    }
+    /* connect timeout is to set 5 secs */
+    tv.tv_sec = 5;
+    tv.tv_usec = 0;
+    if (select(maxfd + 1, NULL, &fds, NULL, &tv) == 0) {
+        goto go_out;
+    } else {
+        for (p = head; p; p = p->next) {
+            if (!FD_ISSET(p->fd, &fds)) {
+                continue;
+            }
+            if (getsockopt(p->fd, SOL_SOCKET, SO_ERROR,
+                           &sockret, &socklen) == 0 &&
+                sockret == 0) {
+                connfd = p->fd;
+                break;
+            }
+        }
+    }
+
+ go_out:
+    p = head;
+    while (p) {
+        if (p->fd != connfd) {
+            close(p->fd);
+        }
+        pn = p->next;
+        free(p);
+        p = pn;
+    }
+    freeaddrinfo(res);
+    return connfd;
+}
+
+void
+mod_websocket_tcp_server_disconnect(int sockfd) {
+    close(sockfd);
+    return;
+}
+
+/* EOF */
--- a/src/mod_websocket_conv.c	1969-12-31 16:00:00.000000000 -0800
+++ b/src//mod_websocket_conv.c	2012-11-14 16:22:34.706025984 -0800
@@ -0,0 +1,176 @@
+/**
+ * $Id$
+ * a part of mod_websocket
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <unicode/ucsdet.h>
+
+#include "mod_websocket.h"
+
+static int mod_websocket_conv(UConverter *, UConverter *,
+                              char **, size_t *, const char *, size_t);
+
+inline int
+mod_websocket_conv(UConverter *to, UConverter *from,
+                   char **dst, size_t *dstsiz,
+                   const char *src, size_t srcsiz) {
+    UErrorCode err = U_ZERO_ERROR;
+    size_t unisiz;
+    UChar *unibuf, *punibuf, *ppunibuf;
+    char *pdst;
+
+    if (srcsiz == 0) {
+        return -1;
+    }
+    if (!to) {
+        *dst = (char *)malloc(srcsiz + 1);
+        if (*dst == NULL) {
+            return -1;
+        }
+        memcpy(*dst, src, srcsiz);
+        (*dst)[srcsiz] = '\0';
+        *dstsiz = srcsiz;
+        return 0;
+    }
+    if (!from || !dst || !src || !dstsiz) {
+        return -1;
+    }
+    unisiz = srcsiz / ucnv_getMinCharSize(from);
+    unibuf = (UChar *)malloc(sizeof(UChar) * unisiz + 1);
+    if (!unibuf) {
+        return -1;
+    }
+    punibuf = unibuf;
+    ucnv_toUnicode(from, &punibuf, punibuf + unisiz,
+                   &src, src + srcsiz, 0, 0, &err);
+    if (U_FAILURE(err)) {
+        free(unibuf);
+        return -1;
+    }
+    *punibuf = '\0';
+    *dstsiz = (punibuf - unibuf) * ucnv_getMaxCharSize(to);
+    *dst = (char *)malloc(*dstsiz + 1);
+    if (!*dst) {
+        free(unibuf);
+        return -1;
+    }
+    pdst = *dst;
+    ppunibuf = unibuf;
+    ucnv_fromUnicode(to, &pdst, pdst + *dstsiz,
+                     (const UChar **)&ppunibuf, punibuf, 0, 0, &err);
+    free(unibuf);
+    if (U_FAILURE(err)) {
+        free(*dst);
+        return -1;
+    }
+    *pdst = '\0';
+    *dstsiz = pdst - *dst;
+    return 0;
+}
+
+mod_websocket_conv_t *
+mod_websocket_conv_init(const char *locale) {
+    mod_websocket_conv_t *cnv;
+    UErrorCode err = U_ZERO_ERROR;
+
+    if (!locale) {
+        return NULL;
+    }
+    cnv = (mod_websocket_conv_t *)malloc(sizeof(mod_websocket_conv_t));
+    if (!cnv) {
+        return NULL;
+    }
+    if (strcasecmp(MOD_WEBSOCKET_UTF8_STR, locale) == 0) {
+        cnv->cli = NULL;
+        cnv->srv = NULL;
+    } else {
+        cnv->cli = ucnv_open(MOD_WEBSOCKET_UTF8_STR, &err);
+        if (U_FAILURE(err)) {
+            free(cnv);
+            return NULL;
+        }
+        cnv->srv = ucnv_open(locale, &err);
+        if (U_FAILURE(err)) {
+            ucnv_close(cnv->cli);
+            free(cnv);
+            return NULL;
+        }
+    }
+    return cnv;
+}
+
+mod_websocket_bool_t
+mod_websocket_conv_isUTF8(const char *data, size_t siz) {
+    mod_websocket_bool_t ret = MOD_WEBSOCKET_FALSE;
+    UErrorCode err = U_ZERO_ERROR;
+    UCharsetDetector *detector = NULL;
+    const UCharsetMatch **match;
+    int32_t f = 0, i;
+    const char *name;
+
+    if (!data || !siz) {
+        return MOD_WEBSOCKET_TRUE;
+    }
+    if (siz > INT32_MAX) {
+        return MOD_WEBSOCKET_FALSE;
+    }
+    detector = ucsdet_open(&err);
+    if (U_FAILURE(err)) {
+        return MOD_WEBSOCKET_FALSE;
+    }
+    ucsdet_setText(detector, data, siz, &err);
+    if (U_FAILURE(err)) {
+        goto go_out;
+    }
+    match = ucsdet_detectAll(detector, &f, &err);
+    if (U_FAILURE(err)) {
+        goto go_out;
+    }
+    for (i = 0; i < f; i++) {
+        name = ucsdet_getName(match[i], &err);
+        if (strcasecmp(MOD_WEBSOCKET_UTF8_STR, name) == 0) {
+            ret = MOD_WEBSOCKET_TRUE;
+            break;
+        }
+    }
+
+ go_out:
+    ucsdet_close(detector);
+    detector = NULL;
+    return ret;
+}
+
+inline int
+mod_websocket_conv_to_client(mod_websocket_conv_t *cnv,
+                             char **dst, size_t *dstsiz,
+                             const char *src, size_t srcsiz) {
+    return mod_websocket_conv(cnv->cli, cnv->srv, dst, dstsiz, src, srcsiz);
+}
+
+inline int
+mod_websocket_conv_to_server(mod_websocket_conv_t *cnv,
+                             char **dst, size_t *dstsiz,
+                             const char *src, size_t srcsiz) {
+    return mod_websocket_conv(cnv->srv, cnv->cli, dst, dstsiz, src, srcsiz);
+}
+
+void
+mod_websocket_conv_final(mod_websocket_conv_t *cnv) {
+    if (cnv) {
+        if (cnv->cli) {
+            ucnv_close(cnv->cli);
+            cnv->cli = NULL;
+        }
+        if (cnv->srv) {
+            ucnv_close(cnv->srv);
+            cnv->srv = NULL;
+        }
+        free(cnv);
+        cnv = NULL;
+    }
+    return;
+}
+
+/* EOF */
--- a/src/mod_websocket_frame.c	1969-12-31 16:00:00.000000000 -0800
+++ b/src/mod_websocket_frame.c	2012-11-14 16:22:34.706025984 -0800
@@ -0,0 +1,847 @@
+/**
+ * $Id$
+ * a part of mod_websocket
+ */
+
+#include <string.h>
+
+#include "mod_websocket.h"
+
+#ifdef	_MOD_WEBSOCKET_SPEC_IETF_00_
+# include "base64.h"
+
+int
+mod_websocket_frame_send_ietf_00(handler_ctx *hctx,
+                                 mod_websocket_frame_type_t type,
+                                 char *payload, size_t siz) {
+    const char additional = 0x00;
+    const unsigned char head = 0x00;
+    const unsigned char tail = 0xff;
+    int ret = -1;
+    buffer *b = NULL;
+    char *enc = NULL;
+    size_t encsiz = 0;
+
+    if (!hctx ||
+        (!payload && (type == MOD_WEBSOCKET_FRAME_TYPE_TEXT ||
+                      type == MOD_WEBSOCKET_FRAME_TYPE_BIN))) {
+        return -1;
+    }
+    if (siz == 0 && (type == MOD_WEBSOCKET_FRAME_TYPE_TEXT ||
+                     type == MOD_WEBSOCKET_FRAME_TYPE_BIN)) {
+        return 0;
+    }
+    b = chunkqueue_get_append_buffer(hctx->tocli);
+    if (!b) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+        return -1;
+    }
+    switch (type) {
+    case MOD_WEBSOCKET_FRAME_TYPE_TEXT:
+        ret = buffer_append_memory(b, (const char *)&head, 1);
+        if (ret != 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+            break;
+        }
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+        ret = mod_websocket_conv_to_client(hctx->cnv,
+                                           &enc, &encsiz, payload, siz);
+        if (ret != 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                      "s", "failed to convert char encodings");
+            break;
+        }
+        ret = buffer_append_memory(b, enc, encsiz);
+        free(enc);
+        enc = NULL;
+#else
+        ret = buffer_append_memory(b, payload, siz);
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+        if (ret != 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+            break;
+        }
+        ret = buffer_append_memory(b, (const char *)&tail, 1);
+        if (ret != 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+            break;
+        }
+        break;
+    case MOD_WEBSOCKET_FRAME_TYPE_BIN:
+        ret = buffer_append_memory(b, (const char *)&head, 1);
+        if (ret != 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+            break;
+        }
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                  "s", "convert binary data into base64 text data");
+        ret = base64_encode((unsigned char **)&enc, &encsiz,
+                            (unsigned char *)payload, siz);
+        if (ret != 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+            break;
+        }
+        ret = buffer_append_memory(b, enc, encsiz);
+        free(enc);
+        enc = NULL;
+        if (ret != 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+            break;
+        }
+        ret = buffer_append_memory(b, (const char *)&tail, 1);
+        if (ret != 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+            break;
+        }
+        break;
+    case MOD_WEBSOCKET_FRAME_TYPE_CLOSE:
+        ret = buffer_append_memory(b, (const char *)&tail, 1);
+        if (ret != 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+            break;
+        }
+        ret = buffer_append_memory(b, (const char *)&head, 1);
+        if (ret != 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+            break;
+        }
+        break;
+    default:
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "not support type");
+        ret = -1;
+        break;
+    }
+    if (ret != 0) {
+        chunkqueue_reset(hctx->tocli);
+        return -1;
+    }
+    /* lighty needs additional char to send */
+    ret = buffer_append_memory(b, &additional, 1);
+    if (ret != 0) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+        chunkqueue_reset(hctx->tocli);
+        return -1;
+    }
+    return 0;
+}
+
+int
+mod_websocket_frame_recv_ietf_00(handler_ctx *hctx) {
+    const char additional = 0x00;
+    char *pff = NULL;
+    chunk *c = NULL;
+    buffer *frame = NULL, *payload = NULL, *b = NULL;
+    int ret;
+    size_t i;
+    char *b64 = NULL;
+    size_t b64siz = 0;
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+    char *enc = NULL;
+    size_t encsiz = 0;
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+    if (!hctx || !hctx->fromcli) {
+        return -1;
+    }
+    if (chunkqueue_is_empty(hctx->fromcli)) {
+        return 0;
+    }
+    for (c = hctx->fromcli->first; c; c = c->next) {
+        frame = c->mem;
+        if (!frame) {
+            continue;
+        }
+        payload = hctx->frame.payload;
+        i = 0;
+        while (i < frame->used - 1) {
+            switch (hctx->frame.state) {
+            case MOD_WEBSOCKET_FRAME_STATE_INIT:
+                hctx->frame.ctl.siz = 0;
+                if (0x00 == frame->ptr[i]) {
+                    hctx->frame.state = MOD_WEBSOCKET_FRAME_STATE_READ_PAYLOAD;
+                    i++;
+                } else {
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                              "s", "recv closing or invalid frame");
+                    chunkqueue_reset(hctx->tosrv);
+                    chunkqueue_reset(hctx->fromcli);
+                    buffer_reset(payload);
+                    return -1;
+                }
+                break;
+            case MOD_WEBSOCKET_FRAME_STATE_READ_PAYLOAD:
+                pff = (char *)memchr(&frame->ptr[i], 0xff, frame->used - i - 1);
+                if (pff == NULL) {
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                              "sx", "got continuous payload size:", frame->used - i - 1);
+                    hctx->frame.ctl.siz += frame->used - i - 1;
+                    if (hctx->frame.ctl.siz > MOD_WEBSOCKET_BUFMAX) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_WARNING,
+                                  "sx", "frame size has beed exceeded:",
+                                  MOD_WEBSOCKET_BUFMAX);
+                        chunkqueue_reset(hctx->tosrv);
+                        chunkqueue_reset(hctx->fromcli);
+                        buffer_reset(payload);
+                        return -1;
+                    }
+                    ret = buffer_append_memory(payload, &frame->ptr[i],
+                                               frame->used - i - 1);
+                    if (ret != 0) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+                        chunkqueue_reset(hctx->tosrv);
+                        chunkqueue_reset(hctx->fromcli);
+                        buffer_reset(payload);
+                        return -1;
+                    }
+                    i += frame->used - i - 1;
+                } else {
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                              "sx", "got final payload size:", (pff - &frame->ptr[i]));
+                    hctx->frame.ctl.siz += (pff - &frame->ptr[i]);
+                    if (hctx->frame.ctl.siz > MOD_WEBSOCKET_BUFMAX) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_WARNING,
+                                  "sx", "frame size has beed exceeded:",
+                                  MOD_WEBSOCKET_BUFMAX);
+                        chunkqueue_reset(hctx->tosrv);
+                        chunkqueue_reset(hctx->fromcli);
+                        buffer_reset(payload);
+                        return -1;
+                    }
+                    ret = buffer_append_memory(payload, &frame->ptr[i],
+                                               pff - &frame->ptr[i]);
+                    if (ret != 0) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+                        chunkqueue_reset(hctx->tosrv);
+                        chunkqueue_reset(hctx->fromcli);
+                        buffer_reset(payload);
+                        return -1;
+                    }
+                    i += (pff - &frame->ptr[i]);
+                    hctx->frame.state = MOD_WEBSOCKET_FRAME_STATE_INIT;
+                }
+                i++;
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+                if (hctx->frame.state != MOD_WEBSOCKET_FRAME_STATE_INIT) {
+                    break;
+                }
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+                hctx->frame.ctl.siz = 0;
+                if (payload->used > 0) {
+                    b = chunkqueue_get_append_buffer(hctx->tosrv);
+                    if (!b) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+                        chunkqueue_reset(hctx->tosrv);
+                        chunkqueue_reset(hctx->fromcli);
+                        buffer_reset(payload);
+                        return -1;
+                    }
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+                    if (mod_websocket_conv_isUTF8(payload->ptr,
+                                                  payload->used) !=
+                        MOD_WEBSOCKET_TRUE) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "recv not UTF-8");
+                        chunkqueue_reset(hctx->tosrv);
+                        chunkqueue_reset(hctx->fromcli);
+                        buffer_reset(payload);
+                        return -1;
+                    }
+                    ret = mod_websocket_conv_to_server(hctx->cnv,
+                                                       &enc, &encsiz,
+                                                       payload->ptr,
+                                                       payload->used);
+                    buffer_reset(payload);
+                    if (ret != 0) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                                  "s", "fail to convert chars");
+                        chunkqueue_reset(hctx->tosrv);
+                        chunkqueue_reset(hctx->fromcli);
+                        return -1;
+                    }
+                    if (hctx->frame.type == MOD_WEBSOCKET_FRAME_TYPE_BIN) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                                  "s", "convert base64 text data into binary data");
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                                  "ss", "receive base64 text:", enc);
+                        ret = base64_decode((unsigned char **)&b64, &b64siz, (unsigned char *)enc);
+                        if (ret != 0) {
+                            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "invalid base64 text");
+                            chunkqueue_reset(hctx->tosrv);
+                            chunkqueue_reset(hctx->fromcli);
+                            return -1;
+                        }
+                        ret = buffer_append_memory(b, b64, b64siz);
+                        free(enc);
+                        free(b64);
+                    } else {
+                        ret = buffer_append_memory(b, enc, encsiz);
+                        free(enc);
+                    }
+                    if (ret != 0) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+                        chunkqueue_reset(hctx->tosrv);
+                        chunkqueue_reset(hctx->fromcli);
+                        return -1;
+                    }
+#else
+                    if (hctx->frame.type == MOD_WEBSOCKET_FRAME_TYPE_BIN) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                                  "s", "convert base64 text data into binary data");
+                        payload->ptr[payload->used] = '\0';
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                                  "ss", "receive base64 text:", payload->ptr);
+                        ret = base64_decode((unsigned char **)&b64, &b64siz,
+                                            (unsigned char *)payload->ptr);
+                        if (ret != 0) {
+                            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "invalid base64 text");
+                            chunkqueue_reset(hctx->tosrv);
+                            chunkqueue_reset(hctx->fromcli);
+                            return -1;
+                        }
+                        ret = buffer_append_memory(b, b64, b64siz);
+                        buffer_reset(payload);
+                        free(b64);
+                    } else {
+                        ret = buffer_append_memory(b, payload->ptr, payload->used);
+                        buffer_reset(payload);
+                    }
+                    if (ret != 0) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+                        chunkqueue_reset(hctx->tosrv);
+                        chunkqueue_reset(hctx->fromcli);
+                        return -1;
+                    }
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+                    /* lighty needs additional char to send */
+                    ret = buffer_append_memory(b, &additional, 1);
+                    if (ret != 0) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+                        chunkqueue_reset(hctx->tosrv);
+                        chunkqueue_reset(hctx->fromcli);
+                        return -1;
+                    }
+                }
+                break;
+            default: /* never reach */
+                DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,"s", "BUG: unknown state");
+                chunkqueue_reset(hctx->tosrv);
+                chunkqueue_reset(hctx->fromcli);
+                buffer_reset(payload);
+                return -1;
+            }
+        }
+    }
+    chunkqueue_reset(hctx->fromcli);
+    return 0;
+}
+#endif	/* _MOD_WEBSOCKET_SPEC_IETF_00_ */
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+int
+mod_websocket_frame_send_rfc_6455(handler_ctx *hctx,
+                                  mod_websocket_frame_type_t type,
+                                  char *payload, size_t siz) {
+    const char additional = 0x00;
+    int ret = -1;
+    char c, len[MOD_WEBSOCKET_FRAME_LEN63 + 1];
+    buffer *b = NULL;
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+    char *enc = NULL;
+    size_t encsiz = 0;
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+    if (!hctx || (!payload &&
+                  (type == MOD_WEBSOCKET_FRAME_TYPE_TEXT ||
+                   type == MOD_WEBSOCKET_FRAME_TYPE_BIN))) {
+        return -1;
+    }
+    b = chunkqueue_get_append_buffer(hctx->tocli);
+    if (!b) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+        return -1;
+    }
+    switch (type) {
+    case MOD_WEBSOCKET_FRAME_TYPE_TEXT:
+        c = (char)(0x80 | MOD_WEBSOCKET_OPCODE_TEXT);
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG, "s", "type: text");
+        break;
+    case MOD_WEBSOCKET_FRAME_TYPE_BIN:
+        c = (char)(0x80 | MOD_WEBSOCKET_OPCODE_BIN);
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG, "s", "type: binary");
+        break;
+    case MOD_WEBSOCKET_FRAME_TYPE_PING:
+        c = (char) (0x80 | MOD_WEBSOCKET_OPCODE_PING);
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG, "s", "type: ping");
+        break;
+    case MOD_WEBSOCKET_FRAME_TYPE_PONG:
+        c = (char)(0x80 | MOD_WEBSOCKET_OPCODE_PONG);
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG, "s", "type: pong");
+        break;
+    case MOD_WEBSOCKET_FRAME_TYPE_CLOSE:
+    default:
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG, "s", "type: close");
+        c = (char)(0x80 | MOD_WEBSOCKET_OPCODE_CLOSE);
+        break;
+    }
+    ret = buffer_append_memory(b, &c, 1);
+    if (ret != 0) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+        buffer_reset(b);
+        return -1;
+    }
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+    if (type == MOD_WEBSOCKET_FRAME_TYPE_TEXT && siz > 0) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                  "sx", "payload size (before convert):", siz);
+        ret = mod_websocket_conv_to_client(hctx->cnv,
+                                           &enc, &encsiz, payload, siz);
+        if (ret != 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "fail to convert encoding");
+            buffer_reset(b);
+            return -1;
+        }
+        siz = encsiz;
+    }
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+    DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG, "sx", "payload size:", siz);
+    memset(len, 0, sizeof(len));
+    if (siz < MOD_WEBSOCKET_FRAME_LEN16) {
+        len[0] = siz;
+        ret = buffer_append_memory(b, len, 1);
+    } else if (siz <= UINT16_MAX) {
+        len[0] = MOD_WEBSOCKET_FRAME_LEN16;
+        len[1] = (siz >> 8) & 0xff;
+        len[2] = siz & 0xff;
+        ret = buffer_append_memory(b, len, MOD_WEBSOCKET_FRAME_LEN16_CNT + 1);
+    } else {
+        len[0] = MOD_WEBSOCKET_FRAME_LEN63;
+        len[5] = (siz >> 24) & 0xff;
+        len[6] = (siz >> 16) & 0xff;
+        len[7] = (siz >> 8) & 0xff;
+        len[8] = siz & 0xff;
+        ret = buffer_append_memory(b, len, MOD_WEBSOCKET_FRAME_LEN63 + 1);
+    }
+    if (ret != 0) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+        if (enc) {
+            free(enc);
+            enc = NULL;
+        }
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+        buffer_reset(b);
+        return -1;
+    }
+    if (siz == 0) {
+        /* lighty needs additional char to send */
+        ret = buffer_append_memory(b, &additional, 1);
+        if (ret != 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+            buffer_reset(b);
+            return -1;
+        }
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG, "sx", "frame size:", b->used - 1);
+        return 0;
+    }
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+    if (type == MOD_WEBSOCKET_FRAME_TYPE_TEXT) {
+        ret = buffer_append_memory(b, enc, siz);
+        free(enc);
+        if (ret != 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+            buffer_reset(b);
+            return -1;
+        }
+    } else
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+    {
+        ret = buffer_append_memory(b, payload, siz);
+        if (ret != 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+            buffer_reset(b);
+            return -1;
+        }
+    }
+
+    /* lighty needs additional char to send */
+    ret = buffer_append_memory(b, &additional, 1);
+    if (ret != 0) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+        buffer_reset(b);
+    }
+    DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG, "sx", "frame size:", b->used - 1);
+    return ret;
+}
+
+void
+unmask_payload(handler_ctx *hctx) {
+    size_t i;
+
+    for (i = 0; i < hctx->frame.payload->used; i++) {
+        hctx->frame.payload->ptr[i] =
+            hctx->frame.payload->ptr[i] ^
+            hctx->frame.ctl.mask[hctx->frame.ctl.mask_cnt];
+        hctx->frame.ctl.mask_cnt = (hctx->frame.ctl.mask_cnt + 1) % 4;
+    }
+    return;
+}
+
+int
+mod_websocket_frame_recv_rfc_6455(handler_ctx *hctx) {
+    /* for debug log */
+    const char *typestr[8] = {"text", "close", "binary", "ping", "pong"};
+    char u64str[128];
+    /* end for debug log */
+    const char additional = 0x00;
+    chunk *c = NULL;
+    buffer *frame = NULL, *payload = NULL, *b = NULL;
+    int ret;
+    size_t i;
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+    char *enc = NULL;
+    size_t encsiz = 0;
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+    if (!hctx || !hctx->fromcli) {
+        return -1;
+    }
+    if (chunkqueue_is_empty(hctx->fromcli)) {
+        return 0;
+    }
+    for (c = hctx->fromcli->first; c; c = c->next) {
+        frame = c->mem;
+        if (!frame) {
+            continue;
+        }
+        payload = hctx->frame.payload;
+        i = 0;
+        while (i < frame->used - 1) {
+            switch (hctx->frame.state) {
+            case MOD_WEBSOCKET_FRAME_STATE_INIT:
+                switch (frame->ptr[i] & 0x0f) {
+                case MOD_WEBSOCKET_OPCODE_CONT:
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO, "s", "type: continue");
+                    hctx->frame.type = hctx->frame.type_before;
+                    break;
+                case MOD_WEBSOCKET_OPCODE_TEXT:
+                    hctx->frame.type = MOD_WEBSOCKET_FRAME_TYPE_TEXT;
+                    hctx->frame.type_before = hctx->frame.type;
+                    break;
+                case MOD_WEBSOCKET_OPCODE_BIN:
+                    hctx->frame.type = MOD_WEBSOCKET_FRAME_TYPE_BIN;
+                    hctx->frame.type_before = hctx->frame.type;
+                    break;
+                case MOD_WEBSOCKET_OPCODE_PING:
+                    hctx->frame.type = MOD_WEBSOCKET_FRAME_TYPE_PING;
+                    break;
+                case MOD_WEBSOCKET_OPCODE_PONG:
+                    hctx->frame.type = MOD_WEBSOCKET_FRAME_TYPE_PONG;
+                    break;
+                case MOD_WEBSOCKET_OPCODE_CLOSE:
+                    hctx->frame.type = MOD_WEBSOCKET_FRAME_TYPE_CLOSE;
+                    chunkqueue_reset(hctx->fromcli);
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                              "ss", "type:", typestr[hctx->frame.type]);
+                    return -1;
+                    break;
+                default:
+                    chunkqueue_reset(hctx->fromcli);
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "type: invalid");
+                    return -1;
+                    break;
+                }
+                DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                          "ss", "type:", typestr[hctx->frame.type]);
+                i++;
+                hctx->frame.state = MOD_WEBSOCKET_FRAME_STATE_READ_LENGTH;
+                break;
+            case MOD_WEBSOCKET_FRAME_STATE_READ_LENGTH:
+                if ((frame->ptr[i] & 0x80) != 0x80) {
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                              "s", "payload was not masked");
+                    chunkqueue_reset(hctx->fromcli);
+                    return -1;
+                }
+                hctx->frame.ctl.mask_cnt = 0;
+                hctx->frame.ctl.siz = (uint64_t)(frame->ptr[i] & 0x7f);
+                if (hctx->frame.ctl.siz == 0) {
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                              "sx", "specified payload size:",
+                              hctx->frame.ctl.siz);
+                    hctx->frame.state = MOD_WEBSOCKET_FRAME_STATE_READ_MASK;
+                } else if (hctx->frame.ctl.siz == MOD_WEBSOCKET_FRAME_LEN16) {
+                    hctx->frame.ctl.siz = 0;
+                    hctx->frame.ctl.siz_cnt = MOD_WEBSOCKET_FRAME_LEN16_CNT;
+                    hctx->frame.state =
+                        MOD_WEBSOCKET_FRAME_STATE_READ_EX_LENGTH;
+                } else if (hctx->frame.ctl.siz == MOD_WEBSOCKET_FRAME_LEN63) {
+                    hctx->frame.ctl.siz = 0;
+                    hctx->frame.ctl.siz_cnt = MOD_WEBSOCKET_FRAME_LEN63_CNT;
+                    hctx->frame.state =
+                        MOD_WEBSOCKET_FRAME_STATE_READ_EX_LENGTH;
+                } else {
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                              "sx", "specified payload size:",
+                              hctx->frame.ctl.siz);
+                    hctx->frame.state = MOD_WEBSOCKET_FRAME_STATE_READ_MASK;
+                }
+                i++;
+                break;
+            case MOD_WEBSOCKET_FRAME_STATE_READ_EX_LENGTH:
+                hctx->frame.ctl.siz =
+                    (hctx->frame.ctl.siz << 8) + (frame->ptr[i] & 0xff);
+                hctx->frame.ctl.siz_cnt--;
+                if (hctx->frame.ctl.siz_cnt <= 0) {
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+                    if ((hctx->frame.type == MOD_WEBSOCKET_FRAME_TYPE_TEXT ||
+                         hctx->frame.type == MOD_WEBSOCKET_FRAME_TYPE_PING) &&
+                        hctx->frame.ctl.siz > MOD_WEBSOCKET_BUFMAX) {
+#else
+                    if (hctx->frame.type == MOD_WEBSOCKET_FRAME_TYPE_PING &&
+                        hctx->frame.ctl.siz > MOD_WEBSOCKET_BUFMAX) {
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_WARNING,
+                                  "sx", "can't handle over",
+                                  MOD_WEBSOCKET_BUFMAX);
+                        chunkqueue_reset(hctx->fromcli);
+                        return -1;
+                    }
+                    if (hctx->pd->conf.debug > MOD_WEBSOCKET_LOG_DEBUG) {
+                        memset(u64str, 0, sizeof(u64str));
+                        snprintf(u64str, sizeof(u64str) - 1,
+                                 "specified payload size: 0x%llx",
+                                 (long long unsigned int)hctx->frame.ctl.siz &
+                                 UINT64_MAX);
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG, "s", u64str);
+                    }
+                    hctx->frame.state = MOD_WEBSOCKET_FRAME_STATE_READ_MASK;
+                }
+                i++;
+                break;
+            case MOD_WEBSOCKET_FRAME_STATE_READ_MASK:
+                hctx->frame.ctl.mask[hctx->frame.ctl.mask_cnt] = frame->ptr[i];
+                hctx->frame.ctl.mask_cnt++;
+                if (hctx->frame.ctl.mask_cnt >= MOD_WEBSOCKET_MASK_CNT) {
+                    hctx->frame.ctl.mask_cnt = 0;
+                    if (hctx->frame.type == MOD_WEBSOCKET_FRAME_TYPE_PING &&
+                        hctx->frame.ctl.siz == 0) {
+                        mod_websocket_frame_send(hctx,
+                                                 MOD_WEBSOCKET_FRAME_TYPE_PONG,
+                                                 NULL, 0);
+                    }
+                    if (hctx->frame.ctl.siz == 0) {
+                        hctx->frame.state = MOD_WEBSOCKET_FRAME_STATE_INIT;
+                    } else {
+                        hctx->frame.state =
+                            MOD_WEBSOCKET_FRAME_STATE_READ_PAYLOAD;
+                    }
+                }
+                i++;
+                break;
+            case MOD_WEBSOCKET_FRAME_STATE_READ_PAYLOAD:
+                /* hctx->frame.ctl.siz <= SIZE_MAX */
+                if (hctx->frame.ctl.siz <= (uint64_t)(frame->used - i - 1)) {
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                              "sx", "got payload size:", hctx->frame.ctl.siz);
+                    ret = buffer_append_memory(payload, &frame->ptr[i],
+                                               (size_t)(hctx->frame.ctl.siz &
+                                                        SIZE_MAX));
+                    i += (size_t)(hctx->frame.ctl.siz & SIZE_MAX);
+                    hctx->frame.ctl.siz = 0;
+                    hctx->frame.state = MOD_WEBSOCKET_FRAME_STATE_INIT;
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                              "sx", "rest of frame size:", frame->used - i - 1);
+                /* SIZE_MAX < hctx->frame.ctl.siz */
+                } else {
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG,
+                              "sx", "got short payload size:",
+                              frame->used - i - 1);
+                    ret = buffer_append_memory(payload, &frame->ptr[i],
+                                               frame->used - i - 1);
+                    hctx->frame.ctl.siz -= (uint64_t)(frame->used - i - 1);
+                    i += (frame->used - i - 1);
+                    if (hctx->pd->conf.debug > MOD_WEBSOCKET_LOG_DEBUG) {
+                        memset(u64str, 0, sizeof(u64str));
+                        snprintf(u64str, sizeof(u64str) - 1,
+                                 "rest of payload size: 0x%llx",
+                                 (long long unsigned int)hctx->frame.ctl.siz &
+                                 UINT64_MAX);
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_DEBUG, "s", u64str);
+                    }
+                }
+                if (ret != 0) {
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+                    hctx->frame.state = MOD_WEBSOCKET_FRAME_STATE_INIT;
+                    chunkqueue_reset(hctx->fromcli);
+                    buffer_reset(payload);
+                    return -1;
+                }
+                switch (hctx->frame.type) {
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+                case MOD_WEBSOCKET_FRAME_TYPE_TEXT:
+                    if (hctx->frame.ctl.siz == 0) {
+                        unmask_payload(hctx);
+                        if (mod_websocket_conv_isUTF8(payload->ptr,
+                                                      payload->used) !=
+                            MOD_WEBSOCKET_TRUE) {
+                            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                                      "s", "recv non UTF-8");
+                            buffer_reset(payload);
+                            return -1;
+                        }
+                        ret = mod_websocket_conv_to_server(hctx->cnv,
+                                                           &enc, &encsiz,
+                                                           payload->ptr,
+                                                           payload->used);
+                        if (ret != 0) {
+                            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                                      "s", "fail to convert chars");
+                            buffer_reset(payload);
+                            return -1;
+                        }
+                        buffer_reset(payload);
+                        b = chunkqueue_get_append_buffer(hctx->tosrv);
+                        if (!b) {
+                            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+                            free(enc);
+                            return -1;
+                        }
+                        ret = buffer_append_memory(b, enc, encsiz);
+                        free(enc);
+                        if (ret != 0) {
+                            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+                            buffer_reset(payload);
+                            return -1;
+                        }
+                        /* lighty needs additional char to send */
+                        ret = buffer_append_memory(b, &additional, 1);
+                        if (ret != 0) {
+                            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+                            chunkqueue_reset(hctx->tosrv);
+                            return -1;
+                        }
+                    }
+                    break;
+#else
+                case MOD_WEBSOCKET_FRAME_TYPE_TEXT:
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+                case MOD_WEBSOCKET_FRAME_TYPE_BIN:
+                    unmask_payload(hctx);
+                    b = chunkqueue_get_append_buffer(hctx->tosrv);
+                    if (!b) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+                        chunkqueue_reset(hctx->fromcli);
+                        buffer_reset(payload);
+                        return -1;
+                    }
+                    ret = buffer_append_memory(b, payload->ptr, payload->used);
+                    buffer_reset(payload);
+                    if (ret != 0) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+                        chunkqueue_reset(hctx->fromcli);
+                        return -1;
+                    }
+                    /* lighty needs additional char to send */
+                    ret = buffer_append_memory(b, &additional, 1);
+                    if (ret != 0) {
+                        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "no memory");
+                        chunkqueue_reset(hctx->tosrv);
+                        return -1;
+                    }
+                    break;
+                case MOD_WEBSOCKET_FRAME_TYPE_PING:
+                    if (hctx->frame.ctl.siz == 0) {
+                        unmask_payload(hctx);
+                        mod_websocket_frame_send(hctx,
+                                                 MOD_WEBSOCKET_FRAME_TYPE_PONG,
+                                                 payload->ptr, payload->used);
+                        buffer_reset(payload);
+                    }
+                    break;
+                case MOD_WEBSOCKET_FRAME_TYPE_PONG:
+                    buffer_reset(payload);
+                    break;
+                case MOD_WEBSOCKET_FRAME_TYPE_CLOSE:
+                default:
+                    DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "BUG: invalid state");
+                    chunkqueue_reset(hctx->fromcli);
+                    buffer_reset(payload);
+                    return -1;
+                }
+                break;
+            default:
+                DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR, "s", "BUG: unknown state");
+                chunkqueue_reset(hctx->fromcli);
+                buffer_reset(payload);
+                return -1;
+            }
+        }
+    }
+    chunkqueue_reset(hctx->fromcli);
+    return 0;
+}
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+int
+mod_websocket_frame_send(handler_ctx *hctx,
+                         mod_websocket_frame_type_t type,
+                         char *payload, size_t siz) {
+    if (!hctx) {
+        return -1;
+    }
+
+#ifdef	_MOD_WEBSOCKET_SPEC_IETF_00_
+    if (hctx->handshake.version == 0) {
+        return mod_websocket_frame_send_ietf_00(hctx, type, payload, siz);
+    }
+#endif	/* _MOD_WEBSOCKET_SPEC_IETF_00_ */
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+    if (hctx->handshake.version >= 8) {
+        return mod_websocket_frame_send_rfc_6455(hctx, type, payload, siz);
+    }
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+    return -1;
+}
+
+int
+mod_websocket_frame_recv(handler_ctx *hctx) {
+    if (!hctx) {
+        return -1;
+    }
+
+#ifdef	_MOD_WEBSOCKET_SPEC_IETF_00_
+    if (hctx->handshake.version == 0) {
+        return mod_websocket_frame_recv_ietf_00(hctx);
+    }
+#endif	/* _MOD_WEBSOCKET_SPEC_IETF_00_ */
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+    if (hctx->handshake.version >= 8) {
+        return mod_websocket_frame_recv_rfc_6455(hctx);
+    }
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+    return -1;
+}
+
+/* EOF */
--- a/src/mod_websocket.h	1969-12-31 16:00:00.000000000 -0800
+++ a/src/mod_websocket.h	2012-11-14 16:22:34.706025984 -0800
@@ -0,0 +1,265 @@
+/*
+ * $Id$
+ *
+ * Copyright(c) 2010, Norio Kobota, All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ *   this list of conditions and the following disclaimer.
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ * - Neither the name of the 'incremental' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	_MOD_WEBSOCKET_H_
+#define	_MOD_WEBSOCKET_H_
+
+#include <stdint.h>
+#include <time.h>
+
+# ifdef	_MOD_WEBSOCKET_WITH_ICU_
+#  include <unicode/ucnv.h>
+# endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+#include "config.h"
+#include "array.h"
+#include "buffer.h"
+#include "chunk.h"
+#include "base.h"
+#include "plugin.h"
+#include "log.h"
+
+#define	MOD_WEBSOCKET_CONFIG_SERVER		"websocket.server"
+#define	MOD_WEBSOCKET_CONFIG_DEBUG		"websocket.debug"
+#define	MOD_WEBSOCKET_CONFIG_TIMEOUT		"websocket.timeout"
+#define	MOD_WEBSOCKET_CONFIG_PING_INTERVAL	"websocket.ping_interval"
+
+#define	MOD_WEBSOCKET_LOG_ERR			(0)
+#define	MOD_WEBSOCKET_LOG_WARNING		(1)
+#define	MOD_WEBSOCKET_LOG_INFO			(2)
+#define	MOD_WEBSOCKET_LOG_DEBUG			(3)
+
+#define	MOD_WEBSOCKET_CONFIG_HOST		"host"
+#define	MOD_WEBSOCKET_CONFIG_PORT		"port"
+#define	MOD_WEBSOCKET_CONFIG_SUBPROTO		"subproto"
+#define	MOD_WEBSOCKET_CONFIG_ORIGINS		"origins"
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+# define	MOD_WEBSOCKET_CONFIG_LOCALE	"locale"
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+#define	MOD_WEBSOCKET_CONFIG_TYPE		"type"
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+# define	MOD_WEBSOCKET_OPCODE_CONT	(0x00)
+# define	MOD_WEBSOCKET_OPCODE_TEXT	(0x01)
+# define	MOD_WEBSOCKET_OPCODE_BIN	(0x02)
+# define	MOD_WEBSOCKET_OPCODE_CLOSE	(0x08)
+# define	MOD_WEBSOCKET_OPCODE_PING	(0x09)
+# define	MOD_WEBSOCKET_OPCODE_PONG	(0x0A)
+
+# define	MOD_WEBSOCKET_FRAME_LEN16	(0x7E)
+# define	MOD_WEBSOCKET_FRAME_LEN63	(0x7F)
+# define	MOD_WEBSOCKET_FRAME_LEN16_CNT	(2)
+# define	MOD_WEBSOCKET_FRAME_LEN63_CNT	(8)
+# define	MOD_WEBSOCKET_MASK_CNT		(4)
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+#define	MOD_WEBSOCKET_BUFMAX			(0xfffff)
+#define	MOD_WEBSOCKET_UTF8_STR			"UTF-8"
+#define	MOD_WEBSOCKET_BIN_STR			"bin"
+#define	MOD_WEBSOCKET_PING_STR			"ping"
+
+typedef unsigned char mod_websocket_bool_t;
+
+#define	MOD_WEBSOCKET_TRUE			(1)
+#define	MOD_WEBSOCKET_FALSE			(0)
+#define	MOD_WEBSOCKET_DEFAULT_TIMEOUT_SEC	(30)
+
+#define DEBUG_LOG(level, format, args...)        \
+    if (hctx->pd->conf.debug > level) {\
+        log_error_write(hctx->srv, __FILE__, __LINE__, format, ## args); \
+    }
+
+#if defined (LIGHTTPD_VERSION_ID) && \
+    (LIGHTTPD_VERSION_ID >= (1 << 16 | 4 << 8 | 30))
+# define	NETWORK_SSL_BACKEND_WRITE(a,b,c,d)\
+    network_ssl_backend_write(a, b, c, d, MAX_WRITE_LIMIT)
+# define	NETWORK_BACKEND_WRITE(a,b,c,d)\
+    network_backend_write(a, b, c, d, MAX_WRITE_LIMIT)
+#else
+# define	NETWORK_SSL_BACKEND_WRITE(a,b,c,d)\
+    network_ssl_backend_write(a, b, c, d)
+# define	NETWORK_BACKEND_WRITE(a,b,c,d)\
+    network_backend_write(a, b, c, d)
+#endif
+
+typedef enum {
+    MOD_WEBSOCKET_NOT_WEBSOCKET		= -1,
+    MOD_WEBSOCKET_OK			= 200,
+    MOD_WEBSOCKET_BAD_REQUEST		= 400,
+    MOD_WEBSOCKET_FORBIDDEN		= 403,
+    MOD_WEBSOCKET_NOT_FOUND		= 404,
+    MOD_WEBSOCKET_INTERNAL_SERVER_ERROR	= 500,
+    MOD_WEBSOCKET_SERVICE_UNAVAILABLE	= 503,
+} mod_websocket_errno_t;
+
+typedef struct {
+    array *exts;
+    unsigned int debug;
+    unsigned int timeout;
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+    unsigned int ping;
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+} plugin_config;
+
+typedef struct {
+    PLUGIN_DATA;
+    plugin_config **config_storage;
+    plugin_config conf;
+} plugin_data;
+
+typedef enum {
+    MOD_WEBSOCKET_STATE_INIT,
+    MOD_WEBSOCKET_STATE_SEND_RESPONSE,
+    MOD_WEBSOCKET_STATE_CONNECTED,
+} mod_websocket_state_t;
+
+typedef struct {
+    buffer *host;
+    buffer *origin;
+    buffer *subproto;
+    int version;
+
+#ifdef	_MOD_WEBSOCKET_SPEC_IETF_00_
+    buffer *key1;
+    buffer *key2;
+    buffer *key3;
+#endif	/* _MOD_WEBSOCKET_SPEC_IETF_00_ */
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+    buffer *key;
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+} mod_websocket_handshake_t;
+
+typedef enum {
+    MOD_WEBSOCKET_FRAME_STATE_INIT,
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+    MOD_WEBSOCKET_FRAME_STATE_READ_LENGTH,
+    MOD_WEBSOCKET_FRAME_STATE_READ_EX_LENGTH,
+    MOD_WEBSOCKET_FRAME_STATE_READ_MASK,
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+    MOD_WEBSOCKET_FRAME_STATE_READ_PAYLOAD,
+} mod_websocket_frame_state_t;
+
+typedef enum {
+    MOD_WEBSOCKET_FRAME_TYPE_TEXT,
+    MOD_WEBSOCKET_FRAME_TYPE_CLOSE,
+    MOD_WEBSOCKET_FRAME_TYPE_BIN,
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+    MOD_WEBSOCKET_FRAME_TYPE_PING,
+    MOD_WEBSOCKET_FRAME_TYPE_PONG,
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+} mod_websocket_frame_type_t;
+
+typedef struct {
+    uint64_t siz;
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+    int siz_cnt;
+    unsigned char mask[MOD_WEBSOCKET_MASK_CNT];
+    int mask_cnt;
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+} mod_websocket_frame_control_t;
+
+typedef struct {
+    mod_websocket_frame_control_t ctl;
+    mod_websocket_frame_state_t state;
+    mod_websocket_frame_type_t type, type_before;
+    buffer *payload;
+} mod_websocket_frame_t;
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+typedef struct {
+    UConverter *cli;
+    UConverter *srv;
+} mod_websocket_conv_t;
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+typedef struct {
+    mod_websocket_state_t state;
+    mod_websocket_handshake_t handshake;
+    mod_websocket_frame_t frame;
+    time_t last_access;
+
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+    mod_websocket_conv_t *cnv;
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+    time_t ping_ts;
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+    /* fd and fd_idx to backend */
+    int fd, fd_idx;
+
+    /* mbuf for server */
+    chunkqueue  *tosrv;		/* chunkqueue to server */
+
+    /* ref */
+    server      *srv;		/* server */
+    connection  *con;		/* connection */
+    data_array  *ext;		/* extention */
+    plugin_data *pd;		/* config */
+
+    chunkqueue  *fromcli;	/* chunkqueue from client */
+    chunkqueue  *tocli;		/* chunkqueue to client */
+} handler_ctx;
+
+/* prototypes */
+#ifdef	_MOD_WEBSOCKET_WITH_ICU_
+mod_websocket_conv_t *mod_websocket_conv_init(const char *);
+mod_websocket_bool_t mod_websocket_conv_isUTF8(const char *, size_t);
+int mod_websocket_conv_to_client(mod_websocket_conv_t *,
+                                 char **, size_t *, const char *, size_t);
+int mod_websocket_conv_to_server(mod_websocket_conv_t *,
+                                 char **, size_t *, const char *, size_t);
+void mod_websocket_conv_final(mod_websocket_conv_t *);
+#endif	/* _MOD_WEBSOCKET_WITH_ICU_ */
+
+mod_websocket_errno_t mod_websocket_handshake_check_request(handler_ctx *);
+mod_websocket_errno_t mod_websocket_handshake_create_response(handler_ctx *);
+
+int mod_websocket_tcp_server_connect(const char *, const char *);
+void mod_websocket_tcp_server_disconnect(int);
+
+int mod_websocket_frame_send(handler_ctx *, mod_websocket_frame_type_t,
+                             char *, size_t);
+int mod_websocket_frame_recv(handler_ctx *);
+
+#endif /* _MOD_WEBSOCKET_H_ */
--- a/src/mod_websocket_handshake.c	1969-12-31 16:00:00.000000000 -0800
+++ b/src//mod_websocket_handshake.c	2012-11-14 16:22:34.706025984 -0800
@@ -0,0 +1,577 @@
+/**
+ * $Id$
+ * a part of mod_websocket
+ **/
+
+#include <ctype.h>
+#include <poll.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include "mod_websocket.h"
+
+#ifdef	_MOD_WEBSOCKET_SPEC_IETF_00_
+# include "md5.h"
+
+# if defined (LIGHTTPD_VERSION_ID) && (LIGHTTPD_VERSION_ID >= (1 << 16 | 4 << 8 | 29))
+typedef li_MD5_CTX MD5_CTX;
+#  define	MD5_Init	li_MD5_Init
+#  define	MD5_Update	li_MD5_Update
+#  define	MD5_Final	li_MD5_Final
+# endif	/* (LIGHTTPD_VERSION_ID) && (LIGHTTPD_VERSION_ID >= (1 << 16 | 4 << 8 | 29)) */
+
+#endif	/* _MOD_WEBSOCKET_SPEC_IETF_00_ */
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+# include <limits.h>
+# ifdef HAVE_STDINT_H
+#  include <stdint.h>
+# endif
+# ifdef HAVE_INTTYPES_H
+#  include <inttypes.h>
+# endif
+# ifndef USE_OPENSSL
+#  include "sha1.h"
+# endif
+# include "base64.h"
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+#define	HOST_STR				"Host"
+#define	CONNECTION_STR				"Connection"
+#define	UPGRADE_STR				"Upgrade"
+#define	CRLF_STR				"\r\n"
+
+#define	WEBSOCKET_STR				"websocket"
+#define	SEC_WEBSOCKET_PROTOCOL_STR		"Sec-WebSocket-Protocol"
+#define	SEC_WEBSOCKET_ORIGIN_STR		"Sec-WebSocket-Origin"
+#define	SEC_WEBSOCKET_VERSION_STR		"Sec-WebSocket-Version"
+#define	ORIGIN_STR				"Origin"
+
+#ifdef	_MOD_WEBSOCKET_SPEC_IETF_00_
+# define	SEC_WEBSOCKET_LOCATION_STR	"Sec-WebSocket-Location"
+# define	SEC_WEBSOCKET_KEY1_STR		"Sec-WebSocket-Key1"
+# define	SEC_WEBSOCKET_KEY2_STR		"Sec-WebSocket-Key2"
+# define	WS_SCHEME_STR			"ws://"
+# define	WSS_SCHEME_STR			"wss://"
+# define	SEC_WEBSOCKET_KEY3_STRLEN	(8)
+# define	MD5_STRLEN			(16)
+#endif	/* _MOD_WEBSOCKET_SPEC_IETF_00_ */
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+# define	SEC_WEBSOCKET_KEY_STR		"Sec-WebSocket-Key"
+# define	SEC_WEBSOCKET_ACCEPT_STR	"Sec-WebSocket-Accept"
+# define	GUID_STR			"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
+# define	ACCEPT_BODY_STRLEN		(32)
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+/* prototypes */
+static mod_websocket_bool_t is_allowed_origin(handler_ctx *);
+static int replace_extension(handler_ctx *);
+
+#ifdef	_MOD_WEBSOCKET_SPEC_IETF_00_
+static int get_key3(handler_ctx *);
+static uint32_t count_spc(buffer *);
+static int get_key_number(uint32_t *, buffer *);
+static int create_MD5_sum(unsigned char *, handler_ctx *);
+static mod_websocket_errno_t create_response_ietf_00(handler_ctx *);
+#endif	/* _MOD_WEBSOCKET_SPEC_IETF_00_ */
+
+#ifdef _MOD_WEBSOCKET_SPEC_RFC_6455_
+static int create_accept_body(unsigned char **, size_t *, handler_ctx *);
+static mod_websocket_errno_t create_response_rfc_6455(handler_ctx *);
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+#ifdef	_MOD_WEBSOCKET_SPEC_IETF_00_
+int
+get_key3(handler_ctx *hctx) {
+    int ret, timeout = 1000; /* XXX: poll timeout = 1000ms */
+    char key3[SEC_WEBSOCKET_KEY3_STRLEN];
+    chunkqueue *q;
+    const char *body = NULL;
+    struct pollfd pfd;
+    ssize_t siz;
+
+    if (!hctx) {
+        return -1;
+    }
+    q = hctx->con->read_queue;
+    if (chunkqueue_is_empty(q)) {
+        pfd.fd = hctx->con->fd;
+        pfd.events = POLLIN;
+        ret = poll(&pfd, 1, timeout);
+        if (ret > 0 && pfd.revents & POLLIN) {
+            siz = read(hctx->con->fd, key3, SEC_WEBSOCKET_KEY3_STRLEN);
+            if (siz != SEC_WEBSOCKET_KEY3_STRLEN) {
+                DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                          "ss", "read error:", strerror(errno));
+                return -1;
+            }
+            ret = buffer_copy_string_len(hctx->handshake.key3, key3,
+                                         SEC_WEBSOCKET_KEY3_STRLEN);
+        } else {
+            ret = -1;
+        }
+    } else {
+        body = &q->first->mem->ptr[q->first->offset];
+        ret = buffer_copy_string_len(hctx->handshake.key3, body,
+                                     SEC_WEBSOCKET_KEY3_STRLEN);
+    }
+    return ret;
+}
+
+uint32_t
+count_spc(buffer *b) {
+    size_t i;
+    uint32_t c = 0;
+
+    if (buffer_is_empty(b)) {
+        return 0;
+    }
+    for (i = b->used; i > 0; i--) {
+        c += (b->ptr[i - 1] == ' ');
+    }
+    return c;
+}
+
+int
+get_key_number(uint32_t *ret, buffer *b) {
+#define	UINT32_MAX_STRLEN	(10)
+    char tmp[UINT32_MAX_STRLEN + 1];
+    size_t i, j = 0;
+    unsigned long n;
+    uint32_t s;
+
+    if (!ret || buffer_is_empty(b)) {
+        return -1;
+    }
+    memset(tmp, 0, sizeof(tmp));
+    for (i = 0; i < b->used; i++) {
+        if (isdigit((int)b->ptr[i])) {
+            tmp[j] = b->ptr[i];
+            j++;
+        }
+        if (UINT32_MAX_STRLEN < j) {
+            return -1;
+        }
+    }
+    n = strtoul(tmp, NULL, 10);
+    if (UINT32_MAX < n) {
+        return -1;
+    }
+    s = count_spc(b);
+    if (s == 0) {
+        return -1;
+    }
+    *ret = (uint32_t)(n / s);
+    return 0;
+#undef	UINT32_MAX_STRLEN
+}
+
+int
+create_MD5_sum(unsigned char *md5sum, handler_ctx *hctx) {
+    unsigned char buf[MD5_STRLEN];
+    uint32_t k1 = 0, k2 = 0;
+    MD5_CTX ctx;
+
+    if (!hctx) {
+        return -1;
+    }
+    if (get_key_number(&k1, hctx->handshake.key1) < 0) {
+        return -1;
+    }
+    if (get_key_number(&k2, hctx->handshake.key2) < 0) {
+        return -1;
+    }
+    if (buffer_is_empty(hctx->handshake.key3)) {
+        return -1;
+    }
+    buf[0] = (k1 >> 24) & 0x0ff;
+    buf[1] = (k1 >> 16) & 0x0ff;
+    buf[2] = (k1 >>  8) & 0x0ff;
+    buf[3] =  k1        & 0x0ff;
+    buf[4] = (k2 >> 24) & 0x0ff;
+    buf[5] = (k2 >> 16) & 0x0ff;
+    buf[6] = (k2 >>  8) & 0x0ff;
+    buf[7] =  k2        & 0x0ff;
+    memcpy(&buf[8], hctx->handshake.key3->ptr, SEC_WEBSOCKET_KEY3_STRLEN);
+    MD5_Init(&ctx);
+    MD5_Update(&ctx, buf, sizeof(buf));
+    MD5_Final(md5sum, &ctx);
+    return 0;
+}
+#endif	/* _MOD_WEBSOCKET_SPEC_IETF_00_ */
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+int
+create_accept_body(unsigned char **digest, size_t *digest_siz, handler_ctx *hctx) {
+    SHA_CTX sha;
+
+# ifdef	USE_OPENSSL
+    uint8_t sha1_digest[SHA_DIGEST_LENGTH];
+# else
+    uint8_t sha1_digest[SHA1_DIGEST_LENGTH];
+# endif
+
+    if (!hctx) {
+        return -1;
+    }
+    if (buffer_is_empty(hctx->handshake.key) ||
+        buffer_append_string(hctx->handshake.key, GUID_STR) < 0) {
+        return -1;
+    }
+    /* get SHA1 hash of key */
+
+# ifdef	USE_OPENSSL
+    if (SHA1_Init(&sha) == 0) {
+        return -1;
+    }
+    if (SHA1_Update(&sha, hctx->handshake.key->ptr,
+                    hctx->handshake.key->used - 1) == 0) {
+        return -1;
+    }
+    if (SHA1_Final(sha1_digest, &sha) == 0) {
+        return -1;
+    }
+    /* get base64 encoded SHA1 hash */
+    if (base64_encode(digest, digest_siz, sha1_digest, SHA_DIGEST_LENGTH) < 0) {
+        return -1;
+    }
+# else
+    SHA1_Init(&sha);
+    SHA1_Update(&sha, (sha1_byte *)hctx->handshake.key->ptr,
+                hctx->handshake.key->used - 1);
+    SHA1_Final(sha1_digest, &sha);
+    /* get base64 encoded SHA1 hash */
+    if (base64_encode(digest, digest_siz, sha1_digest, SHA1_DIGEST_LENGTH) < 0) {
+        return -1;
+    }
+#endif
+
+    return 0;
+}
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+mod_websocket_bool_t
+is_allowed_origin(handler_ctx *hctx) {
+    size_t i;
+    data_array *cfg_origins = NULL;
+    array *allowed_origins = NULL;
+    data_string *allowed_origin = NULL;
+
+    cfg_origins = (data_array *)array_get_element(hctx->ext->value,
+                                                  MOD_WEBSOCKET_CONFIG_ORIGINS);
+    if (!cfg_origins ||
+        !cfg_origins->value || !cfg_origins->value->used) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                  "s", "allowed origins are not specified");
+        return MOD_WEBSOCKET_TRUE;
+    }
+    allowed_origins = cfg_origins->value;
+    if (!hctx->handshake.origin) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                  "s", "request has no origin");
+        return MOD_WEBSOCKET_FALSE;
+    }
+    for (i = allowed_origins->used; i > 0; i--) {
+        allowed_origin = (data_string *)allowed_origins->data[i - 1];
+        if (NULL != strstr(hctx->handshake.origin->ptr,
+                           allowed_origin->value->ptr)) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                      "ss", "allowed origin:", hctx->handshake.origin->ptr);
+            return MOD_WEBSOCKET_TRUE;
+        }
+    }
+    DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+              "ss", "not allowed origin:", hctx->handshake.origin->ptr);
+    return MOD_WEBSOCKET_FALSE;
+}
+
+int
+replace_extension(handler_ctx *hctx) {
+    size_t i;
+    data_array *da_subproto = NULL;
+    array *subprotos;
+    buffer *subproto;
+
+    if (!hctx || !hctx->ext || !hctx->ext->value) {
+        return -1;
+    }
+    subprotos = hctx->ext->value;
+    subproto = hctx->handshake.subproto;
+    for (i = subprotos->used; i > 0; i--) {
+        da_subproto = (data_array *)subprotos->data[i - 1];
+        if (buffer_is_empty(subproto)) {
+            if (da_subproto->is_index_key) {
+                hctx->ext = (data_array *)da_subproto;
+                DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                          "s", "found extension w/o subproto");
+                return 0;
+            }
+        } else {
+            if (!buffer_is_empty(da_subproto->key) &&
+                strstr(subproto->ptr, da_subproto->key->ptr) != NULL) {
+                hctx->ext = (data_array *)da_subproto;
+                DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                          "ss", "found subproto extension:",
+                          hctx->handshake.subproto->ptr);
+                return 0;
+            }
+        }
+    }
+    if (buffer_is_empty(subproto)) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                  "s", "not found extension w/o subproto");
+    } else {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                  "ss", "not found subproto extension:",
+                  hctx->handshake.subproto->ptr);
+    }
+    return -1;
+}
+
+mod_websocket_errno_t
+mod_websocket_handshake_check_request(handler_ctx *hctx) {
+    size_t i;
+    array *hdrs;
+    data_string *hdr = NULL;
+    mod_websocket_handshake_t *handshake;
+    buffer *con = NULL;
+    buffer *upgrade = NULL;
+    buffer *version = NULL;
+    char *endp;
+
+    if (!hctx || !hctx->con || !hctx->srv) {
+        return MOD_WEBSOCKET_INTERNAL_SERVER_ERROR;
+    }
+    hdrs = hctx->con->request.headers;
+    handshake = &hctx->handshake;
+
+    /* store necessary headers */
+    for (i = hdrs->used; i > 0; i--) {
+        hdr = (data_string *)hdrs->data[i - 1];
+        if (buffer_is_empty(hdr->key) || buffer_is_empty(hdr->value)) {
+            continue;
+        }
+        if (buffer_is_equal_string(hdr->key, CONST_STR_LEN(CONNECTION_STR))) {
+            con = hdr->value;
+        }
+        if (buffer_is_equal_string(hdr->key, CONST_STR_LEN(UPGRADE_STR))) {
+            upgrade = hdr->value;
+        }
+        if (buffer_is_equal_string(hdr->key, CONST_STR_LEN(HOST_STR))) {
+            handshake->host = hdr->value;
+        }
+        if (buffer_is_equal_string(hdr->key,
+                                   CONST_STR_LEN(SEC_WEBSOCKET_PROTOCOL_STR))) {
+            handshake->subproto = hdr->value;
+        }
+        if (buffer_is_equal_string(hdr->key,
+                                   CONST_STR_LEN(SEC_WEBSOCKET_VERSION_STR))) {
+            version = hdr->value;
+        }
+        if (buffer_is_equal_string(hdr->key, CONST_STR_LEN(ORIGIN_STR)) ||
+            buffer_is_equal_string(hdr->key,
+                                   CONST_STR_LEN(SEC_WEBSOCKET_ORIGIN_STR))) {
+            handshake->origin = hdr->value;
+        }
+
+#ifdef	_MOD_WEBSOCKET_SPEC_IETF_00_
+        if (buffer_is_equal_string(hdr->key,
+                                   CONST_STR_LEN(SEC_WEBSOCKET_KEY1_STR))) {
+            handshake->key1 = hdr->value;
+        }
+        if (buffer_is_equal_string(hdr->key,
+                                   CONST_STR_LEN(SEC_WEBSOCKET_KEY2_STR))) {
+            handshake->key2 = hdr->value;
+        }
+#endif	/* _MOD_WEBSOCKET_SPEC_IETF_00_ */
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+        if (buffer_is_equal_string(hdr->key,
+                                   CONST_STR_LEN(SEC_WEBSOCKET_KEY_STR))) {
+            handshake->key = hdr->value;
+        }
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+    }
+    if (buffer_is_empty(version)) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO, "s",
+                  "not found Sec-WebSocket-Version header. assume hybi-00");
+        handshake->version = 0;
+    } else {
+        endp = version->ptr + version->used - 1;
+        handshake->version = (int)(strtol(version->ptr, &endp, 10) & INT_MAX);
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO, "sd",
+                  "Sec-WebSocket-Version:", handshake->version);
+    }
+    /* check store headers */
+    if (buffer_is_empty(con) || buffer_is_empty(upgrade)) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                  "s", "not found WebSocket specific headers");
+        return MOD_WEBSOCKET_NOT_WEBSOCKET;
+    }
+    buffer_to_lower(upgrade);
+    if (strstr(con->ptr, UPGRADE_STR) == NULL ||
+        !buffer_is_equal_string(upgrade, CONST_STR_LEN(WEBSOCKET_STR))) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_INFO,
+                  "s", "not found WebSocket specific headers");
+        return MOD_WEBSOCKET_NOT_WEBSOCKET;
+    }
+    if (buffer_is_empty(handshake->host)) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                  "s", "not found HOST header");
+        return MOD_WEBSOCKET_BAD_REQUEST;
+    }
+    if (0 < handshake->version && handshake->version < 8) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                  "s", "specified WebSocket version is not supported");
+        return MOD_WEBSOCKET_SERVICE_UNAVAILABLE;
+    }
+
+#ifdef	_MOD_WEBSOCKET_SPEC_IETF_00_
+    if (handshake->version == 0) {
+        if (buffer_is_empty(handshake->key1) || buffer_is_empty(handshake->key2) ||
+            get_key3(hctx) < 0) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                      "s", "not found Sec-WebSocket-Key{1,2,3} header");
+            return MOD_WEBSOCKET_BAD_REQUEST;
+        }
+    }
+#endif	/* _MOD_WEBSOCKET_SPEC_IETF_00_ */
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+    if (handshake->version >= 8) {
+        if (buffer_is_empty(handshake->key)) {
+            DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                      "s", "not found Sec-WebSocket-Key header");
+            return MOD_WEBSOCKET_BAD_REQUEST;
+        }
+    }
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+    if (buffer_is_empty(handshake->origin)) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                  "s", "not found Origin header");
+        return MOD_WEBSOCKET_BAD_REQUEST;
+    }
+    /* replace hctx->ext if subproto exsists */
+    if (replace_extension(hctx) < 0) {
+        return MOD_WEBSOCKET_NOT_FOUND;
+    }
+    if (is_allowed_origin(hctx) != MOD_WEBSOCKET_TRUE) {
+        return MOD_WEBSOCKET_FORBIDDEN;
+    }
+    return MOD_WEBSOCKET_OK;
+}
+
+#ifdef	_MOD_WEBSOCKET_SPEC_IETF_00_
+mod_websocket_errno_t
+create_response_ietf_00(handler_ctx *hctx) {
+    const char *const_hdrs =
+        "HTTP/1.1 101 Web Socket Protocol Handshake\r\n"
+        "Upgrade: WebSocket\r\n"
+        "Connection: Upgrade\r\n";
+    buffer *resp = NULL;
+    unsigned char md5sum[MD5_STRLEN];
+
+    resp = chunkqueue_get_append_buffer(hctx->tocli);
+    buffer_append_string(resp, const_hdrs);
+    /* Sec-WebSocket-Protocol header if exists */
+    if (!buffer_is_empty(hctx->handshake.subproto)) {
+        buffer_append_string(resp, SEC_WEBSOCKET_PROTOCOL_STR ": ");
+        buffer_append_string_buffer(resp, hctx->handshake.subproto);
+        buffer_append_string(resp, CRLF_STR);
+    }
+    /* Sec-WebSocket-Origin header */
+    buffer_append_string(resp, SEC_WEBSOCKET_ORIGIN_STR ": ");
+    buffer_append_string_buffer(resp, hctx->handshake.origin);
+    buffer_append_string(resp, CRLF_STR);
+    /* Sec-WebSocket-Location header */
+    buffer_append_string(resp, SEC_WEBSOCKET_LOCATION_STR ": ");
+    if (((server_socket *)(hctx->con->srv_socket))->is_ssl) {
+
+# ifdef	USE_OPENSSL
+        buffer_append_string(resp, WSS_SCHEME_STR);
+# else	/* SSL is not available */
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                  "s", "wss scheme is not available");
+        return MOD_WEBSOCKET_BAD_REQUEST;
+# endif	/* USE_OPENSSL */
+
+    } else {
+        buffer_append_string(resp, WS_SCHEME_STR);
+    }
+    buffer_append_string_buffer(resp, hctx->handshake.host);
+    buffer_append_string_buffer(resp, hctx->con->uri.path);
+    buffer_append_string(resp, CRLF_STR);
+    buffer_append_string(resp, CRLF_STR);
+    /* MD5 sum in body */
+    if (create_MD5_sum(md5sum, hctx) < 0) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                  "s", "invalid Sec-WebSocket-Key");
+        return MOD_WEBSOCKET_BAD_REQUEST;
+    }
+    buffer_append_string_len(resp, (char *)md5sum, MD5_STRLEN);
+    return MOD_WEBSOCKET_OK;
+}
+#endif	/* _MOD_WEBSOCKET_SPEC_IETF_00_ */
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+mod_websocket_errno_t
+create_response_rfc_6455(handler_ctx *hctx) {
+    const char *const_hdrs =
+        "HTTP/1.1 101 Switching Protocols\r\n"
+        "Upgrade: websocket\r\n"
+        "Connection: Upgrade\r\n";
+    buffer *resp = NULL;
+    unsigned char *accept_body;
+    size_t accept_body_siz;
+
+    resp = chunkqueue_get_append_buffer(hctx->tocli);
+    buffer_append_string(resp, const_hdrs);
+
+    /* Sec-WebSocket-Protocol header if exists */
+    if (!buffer_is_empty(hctx->handshake.subproto)) {
+        buffer_append_string(resp, SEC_WEBSOCKET_PROTOCOL_STR ": ");
+        buffer_append_string_buffer(resp, hctx->ext->key);
+        buffer_append_string(resp, CRLF_STR);
+    }
+    /* Sec-WebSocket-Accept header */
+    if (create_accept_body(&accept_body, &accept_body_siz, hctx) < 0) {
+        DEBUG_LOG(MOD_WEBSOCKET_LOG_ERR,
+                  "s", "invalid Sec-WebSocket-Key");
+        return MOD_WEBSOCKET_BAD_REQUEST;
+    }
+    buffer_append_string(resp, SEC_WEBSOCKET_ACCEPT_STR ": ");
+    buffer_append_string_len(resp, (char *)accept_body, accept_body_siz);
+    free(accept_body);
+    buffer_append_string(resp, CRLF_STR);
+    buffer_append_string(resp, CRLF_STR);
+    return MOD_WEBSOCKET_OK;
+}
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+mod_websocket_errno_t
+mod_websocket_handshake_create_response(handler_ctx *hctx) {
+    if (!hctx) {
+        return MOD_WEBSOCKET_INTERNAL_SERVER_ERROR;
+    }
+
+#ifdef	_MOD_WEBSOCKET_SPEC_IETF_00_
+    if (hctx->handshake.version == 0) {
+        return create_response_ietf_00(hctx);
+    }
+#endif	/* _MOD_WEBSOCKET_SPEC_IETF_00_ */
+
+#ifdef	_MOD_WEBSOCKET_SPEC_RFC_6455_
+    if (hctx->handshake.version >= 8) {
+        return create_response_rfc_6455(hctx);
+    }
+#endif	/* _MOD_WEBSOCKET_SPEC_RFC_6455_ */
+
+    return MOD_WEBSOCKET_BAD_REQUEST;
+}
+
+/* EOF */
--- a/src/sha1.c	1969-12-31 16:00:00.000000000 -0800
+++ b/src/sha1.c	2012-11-14 16:22:34.706025984 -0800
@@ -0,0 +1,157 @@
+/*
+ * sha1.c
+ *
+ * Originally witten by Steve Reid <steve@edmweb.com>
+ *
+ * Modified by Aaron D. Gifford <agifford@infowest.com>
+ *
+ * NO COPYRIGHT - THIS IS 100% IN THE PUBLIC DOMAIN
+ *
+ * The original unmodified version is available at:
+ *    ftp://ftp.funet.fi/pub/crypt/hash/sha/sha1.c
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <string.h>
+
+#include "sha1.h"
+
+#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
+
+/* blk0() and blk() perform the initial expand. */
+/* I got the idea of expanding during the round function from SSLeay */
+
+#ifdef LITTLE_ENDIAN
+#define blk0(i) (block->l[i] = (rol(block->l[i],24)&(sha1_quadbyte)0xFF00FF00) \
+    |(rol(block->l[i],8)&(sha1_quadbyte)0x00FF00FF))
+#else
+#define blk0(i) block->l[i]
+#endif
+
+#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
+    ^block->l[(i+2)&15]^block->l[i&15],1))
+
+/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */
+#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
+#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
+#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
+#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
+#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);
+
+typedef union _BYTE64QUAD16 {
+    sha1_byte c[64];
+    sha1_quadbyte l[16];
+} BYTE64QUAD16;
+
+/* Hash a single 512-bit block. This is the core of the algorithm. */
+void SHA1_Transform(sha1_quadbyte state[5], sha1_byte buffer[64]) {
+    sha1_quadbyte a, b, c, d, e;
+    BYTE64QUAD16 *block;
+
+    block = (BYTE64QUAD16*)buffer;
+    /* Copy context->state[] to working vars */
+    a = state[0];
+    b = state[1];
+    c = state[2];
+    d = state[3];
+    e = state[4];
+    /* 4 rounds of 20 operations each. Loop unrolled. */
+    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
+    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
+    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
+    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
+    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
+    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
+    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
+    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
+    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
+    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
+    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
+    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
+    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
+    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
+    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
+    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
+    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
+    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
+    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
+    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
+    /* Add the working vars back into context.state[] */
+    state[0] += a;
+    state[1] += b;
+    state[2] += c;
+    state[3] += d;
+    state[4] += e;
+    /* Wipe variables */
+    a = b = c = d = e = 0;
+}
+
+
+/* SHA1_Init - Initialize new context */
+void SHA1_Init(SHA_CTX* context) {
+    /* SHA1 initialization constants */
+    context->state[0] = 0x67452301;
+    context->state[1] = 0xEFCDAB89;
+    context->state[2] = 0x98BADCFE;
+    context->state[3] = 0x10325476;
+    context->state[4] = 0xC3D2E1F0;
+    context->count[0] = context->count[1] = 0;
+}
+
+/* Run your data through this. */
+void SHA1_Update(SHA_CTX *context, sha1_byte *data, unsigned int len) {
+    unsigned int i, j;
+
+    j = (context->count[0] >> 3) & 63;
+    if ((context->count[0] += len << 3) < (len << 3)) context->count[1]++;
+    context->count[1] += (len >> 29);
+    if ((j + len) > 63) {
+        memcpy(&context->buffer[j], data, (i = 64-j));
+        SHA1_Transform(context->state, context->buffer);
+        for ( ; i + 63 < len; i += 64) {
+            SHA1_Transform(context->state, &data[i]);
+        }
+        j = 0;
+    }
+    else i = 0;
+    memcpy(&context->buffer[j], &data[i], len - i);
+}
+
+
+/* Add padding and return the message digest. */
+void SHA1_Final(sha1_byte digest[SHA1_DIGEST_LENGTH], SHA_CTX *context) {
+    sha1_quadbyte i, j;
+    sha1_byte finalcount[8];
+
+    for (i = 0; i < 8; i++) {
+        finalcount[i] = (sha1_byte)((context->count[(i >= 4 ? 0 : 1)]
+         >> ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */
+    }
+    SHA1_Update(context, (sha1_byte *)"\200", 1);
+    while ((context->count[0] & 504) != 448) {
+        SHA1_Update(context, (sha1_byte *)"\0", 1);
+    }
+    /* Should cause a SHA1_Transform() */
+    SHA1_Update(context, finalcount, 8);
+    for (i = 0; i < SHA1_DIGEST_LENGTH; i++) {
+        digest[i] = (sha1_byte)
+         ((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
+    }
+    /* Wipe variables */
+    i = j = 0;
+    memset(context->buffer, 0, SHA1_BLOCK_LENGTH);
+    memset(context->state, 0, SHA1_DIGEST_LENGTH);
+    memset(context->count, 0, 8);
+    memset(&finalcount, 0, 8);
+}
--- a/src/sha1.h	1969-12-31 16:00:00.000000000 -0800
+++ b/src/sha1.h	2012-11-14 16:22:34.706025984 -0800
@@ -0,0 +1,80 @@
+/*
+ * sha.h
+ *
+ * Originally taken from the public domain SHA1 implementation
+ * written by by Steve Reid <steve@edmweb.com>
+ * 
+ * Modified by Aaron D. Gifford <agifford@infowest.com>
+ *
+ * NO COPYRIGHT - THIS IS 100% IN THE PUBLIC DOMAIN
+ *
+ * The original unmodified version is available at:
+ *    ftp://ftp.funet.fi/pub/crypt/hash/sha/sha1.c
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __SHA1_H__
+#define __SHA1_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Define this if your machine is LITTLE_ENDIAN, otherwise #undef it: */
+#ifdef WORDS_BIGENDIAN
+# undef		LITTLE_ENDIAN
+#else
+# ifndef LITTLE_ENDIAN
+#  define	LITTLE_ENDIAN
+# endif
+#endif
+
+/* Make sure you define these types for your architecture: */
+typedef unsigned int sha1_quadbyte;	/* 4 byte type */
+typedef unsigned char sha1_byte;	/* single byte type */
+
+/*
+ * Be sure to get the above definitions right.  For instance, on my
+ * x86 based FreeBSD box, I define LITTLE_ENDIAN and use the type
+ * "unsigned long" for the quadbyte.  On FreeBSD on the Alpha, however,
+ * while I still use LITTLE_ENDIAN, I must define the quadbyte type
+ * as "unsigned int" instead.
+ */
+
+#define SHA1_BLOCK_LENGTH	64
+#define SHA1_DIGEST_LENGTH	20
+
+/* The SHA1 structure: */
+typedef struct _SHA_CTX {
+	sha1_quadbyte	state[5];
+	sha1_quadbyte	count[2];
+	sha1_byte	buffer[SHA1_BLOCK_LENGTH];
+} SHA_CTX;
+
+#ifndef NOPROTO
+void SHA1_Init(SHA_CTX *context);
+void SHA1_Update(SHA_CTX *context, sha1_byte *data, unsigned int len);
+void SHA1_Final(sha1_byte digest[SHA1_DIGEST_LENGTH],
+                   SHA_CTX* context);
+#else
+void SHA1_Init();
+void SHA1_Update();
+void SHA1_Final();
+#endif
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif
